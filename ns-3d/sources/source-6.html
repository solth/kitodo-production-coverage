


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > CalendarForm</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.kitodo.production.forms</a>
</div>

<h1>Coverage Summary for Class: CalendarForm (org.kitodo.production.forms)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">CalendarForm</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/60)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    0%
  </span>
  <span class="absValue">
    (0/242)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * (c) Kitodo. Key to digital objects e. V. &lt;contact@kitodo.org&gt;
&nbsp; *
&nbsp; * This file is part of the Kitodo project.
&nbsp; *
&nbsp; * It is licensed under GNU General Public License version 3 or later.
&nbsp; *
&nbsp; * For the full copyright and license information, please read the
&nbsp; * GPL3-License.txt file that was distributed with this source code.
&nbsp; */
&nbsp;
&nbsp;package org.kitodo.production.forms;
&nbsp;
&nbsp;import java.io.ByteArrayInputStream;
&nbsp;import java.io.IOException;
&nbsp;import java.io.Serializable;
&nbsp;import java.text.DecimalFormat;
&nbsp;import java.time.DateTimeException;
&nbsp;import java.time.LocalDate;
&nbsp;import java.time.Month;
&nbsp;import java.time.MonthDay;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Calendar;
&nbsp;import java.util.Date;
&nbsp;import java.util.GregorianCalendar;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.NoSuchElementException;
&nbsp;import java.util.Objects;
&nbsp;import java.util.regex.Matcher;
&nbsp;import java.util.regex.Pattern;
&nbsp;
&nbsp;import javax.faces.context.FacesContext;
&nbsp;import javax.faces.view.ViewScoped;
&nbsp;import javax.inject.Named;
&nbsp;import javax.naming.ConfigurationException;
&nbsp;import javax.xml.transform.TransformerException;
&nbsp;
&nbsp;import org.apache.commons.lang3.tuple.ImmutablePair;
&nbsp;import org.apache.commons.lang3.tuple.Pair;
&nbsp;import org.apache.commons.lang3.tuple.Triple;
&nbsp;import org.apache.logging.log4j.LogManager;
&nbsp;import org.apache.logging.log4j.Logger;
&nbsp;import org.kitodo.config.ConfigCore;
&nbsp;import org.kitodo.config.enums.ParameterCore;
&nbsp;import org.kitodo.data.database.beans.Process;
&nbsp;import org.kitodo.data.database.exceptions.DAOException;
&nbsp;import org.kitodo.data.exceptions.DataException;
&nbsp;import org.kitodo.exceptions.DoctypeMissingException;
&nbsp;import org.kitodo.exceptions.ProcessGenerationException;
&nbsp;import org.kitodo.production.forms.createprocess.ProcessDetail;
&nbsp;import org.kitodo.production.forms.createprocess.ProcessTextMetadata;
&nbsp;import org.kitodo.production.helper.Helper;
&nbsp;import org.kitodo.production.helper.XMLUtils;
&nbsp;import org.kitodo.production.helper.tasks.GeneratesNewspaperProcessesThread;
&nbsp;import org.kitodo.production.helper.tasks.TaskManager;
&nbsp;import org.kitodo.production.model.bibliography.course.Block;
&nbsp;import org.kitodo.production.model.bibliography.course.Cell;
&nbsp;import org.kitodo.production.model.bibliography.course.Course;
&nbsp;import org.kitodo.production.model.bibliography.course.Granularity;
&nbsp;import org.kitodo.production.model.bibliography.course.IndividualIssue;
&nbsp;import org.kitodo.production.model.bibliography.course.Issue;
&nbsp;import org.kitodo.production.model.bibliography.course.metadata.CountableMetadata;
&nbsp;import org.kitodo.production.process.NewspaperProcessesGenerator;
&nbsp;import org.kitodo.production.services.ServiceManager;
&nbsp;import org.kitodo.production.services.calendar.CalendarService;
&nbsp;import org.kitodo.production.services.data.ImportService;
&nbsp;import org.primefaces.PrimeFaces;
&nbsp;import org.primefaces.model.DefaultStreamedContent;
&nbsp;import org.primefaces.model.StreamedContent;
&nbsp;import org.primefaces.model.file.UploadedFile;
&nbsp;import org.w3c.dom.Document;
&nbsp;import org.xml.sax.SAXException;
&nbsp;
&nbsp;/**
&nbsp; * The class CalendarForm provides the screen logic for a JSF calendar editor to
&nbsp; * enter the course of appearance of a newspaper.
&nbsp; */
&nbsp;@Named(&quot;CalendarForm&quot;)
&nbsp;@ViewScoped
&nbsp;public class CalendarForm implements Serializable {
<b class="nc">&nbsp;    private static final Logger logger = LogManager.getLogger(CalendarForm.class);</b>
&nbsp;
&nbsp;    private static final String BLOCK = &quot;calendar.block.&quot;;
&nbsp;    private static final String BLOCK_NEGATIVE = BLOCK + &quot;negative&quot;;
&nbsp;    private static final String UPLOAD_ERROR = &quot;calendar.upload.error&quot;;
&nbsp;    private static final String REDIRECT_PARAMETER = &quot;faces-redirect=true&quot;;
&nbsp;    private static final String DEFAULT_REFERER = &quot;processes?&quot; + REDIRECT_PARAMETER;
&nbsp;    private static final String TASK_MANAGER_REFERER = &quot;system.jsf?tabIndex=0&amp;&quot; + REDIRECT_PARAMETER;
<b class="nc">&nbsp;    private static final Integer[] MONTHS = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};</b>
&nbsp;
&nbsp;    /**
&nbsp;     * This is a regular expression to parse date inputs in a flexible way.
&nbsp;     */
<b class="nc">&nbsp;    private static final Pattern FLEXIBLE_DATE = Pattern.compile(&quot;\\D*(\\d+)\\D+(\\d+)\\D+(\\d+)\\D*&quot;);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The constant field issueColours holds the colors used to represent the
&nbsp;     * issues in the calendar editor.
&nbsp;     */
&nbsp;    private static String[] issueColours;
&nbsp;
&nbsp;    /**
&nbsp;     * The constant field START_RELATION hold the date the course of publication
&nbsp;     * of the the German-language “Relation aller Fürnemmen und gedenckwürdigen
&nbsp;     * Historien”, which is often recognized as the first newspaper, began. If
&nbsp;     * the user tries to create a block before that date, a hint will be shown.
&nbsp;     */
<b class="nc">&nbsp;    private static final LocalDate START_RELATION = LocalDate.of(1605, 9, 12);</b>
&nbsp;
<b class="nc">&nbsp;    private String referer = DEFAULT_REFERER;</b>
<b class="nc">&nbsp;    private Granularity granularity = Granularity.ISSUES;</b>
<b class="nc">&nbsp;    private int numberOfPagesPerIssue = 0;</b>
<b class="nc">&nbsp;    protected int yearShowing = 1979;</b>
&nbsp;    private UploadedFile uploadedFile;
&nbsp;    private LocalDate selectedDate;
<b class="nc">&nbsp;    private Block selectedBlock = null;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * The field course holds the course of appearance currently under edit by
&nbsp;     * this calendar form instance.
&nbsp;     */
&nbsp;    protected Course course;
&nbsp;
&nbsp;    /**
&nbsp;     * The constant field today hold the date of today. Reading the system clock
&nbsp;     * requires much synchronisation throughout the JVM and is therefore only
&nbsp;     * done once on form creation.
&nbsp;     */
<b class="nc">&nbsp;    private final LocalDate today = LocalDate.now();</b>
&nbsp;    private static Integer parentId;
&nbsp;
<b class="nc">&nbsp;    private String activeIndexes = &quot;0&quot;;</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Empty constructor. Creates a new form without yet any data.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * The issue color presets are samples which have been chosen to provide
&nbsp;     * distinguishability also for users with red-green color vision deficiency.
&nbsp;     * Arbitrary colors can be defined in kitodo_config.properties by setting
&nbsp;     * the property “issue.colours”.
&nbsp;     */
<b class="nc">&nbsp;    public CalendarForm() {</b>
<b class="nc">&nbsp;        issueColours = ConfigCore.getParameterOrDefaultValue(ParameterCore.ISSUE_COLOURS).split(&quot;;&quot;);</b>
<b class="nc">&nbsp;        course = new Course();</b>
&nbsp;
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets activeIndexes.
&nbsp;     *
&nbsp;     * @return value of activeIndexes
&nbsp;     */
&nbsp;    public String getActiveIndexes() {
<b class="nc">&nbsp;        return activeIndexes;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets activeIndexes.
&nbsp;     *
&nbsp;     * @param activeIndexes value of activeIndexes
&nbsp;     */
&nbsp;    public void setActiveIndexes(String activeIndexes) {
<b class="nc">&nbsp;        this.activeIndexes = activeIndexes;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get referer.
&nbsp;     *
&nbsp;     * @return value of referer
&nbsp;     */
&nbsp;    public String getReferer() {
<b class="nc">&nbsp;        return referer;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set referer.
&nbsp;     *
&nbsp;     * @param referer as java.lang.String
&nbsp;     */
&nbsp;    public void setReferer(String referer) {
<b class="nc">&nbsp;        if (Objects.nonNull(referer) &amp;&amp; !referer.isEmpty()) {</b>
<b class="nc">&nbsp;            this.referer = referer;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set parent processId.
&nbsp;     *
&nbsp;     * @param parentId as java.lang.Integer
&nbsp;     */
&nbsp;    public void setParentId(Integer parentId) {
<b class="nc">&nbsp;        if (Objects.nonNull(parentId)) {</b>
<b class="nc">&nbsp;            this.parentId = parentId;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets parentId.
&nbsp;     *
&nbsp;     * @return value of parentId
&nbsp;     */
&nbsp;    public static Integer getParentId() {
<b class="nc">&nbsp;        return parentId;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get all possible granularities.
&nbsp;     *
&nbsp;     * @return list of Granularity objects
&nbsp;     */
&nbsp;    public List&lt;Granularity&gt; getGranularities() {
<b class="nc">&nbsp;        return Arrays.asList(Granularity.values());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get granularity.
&nbsp;     *
&nbsp;     * @return value of granularity
&nbsp;     */
&nbsp;    public Granularity getGranularity() {
<b class="nc">&nbsp;        return granularity;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set granularity.
&nbsp;     *
&nbsp;     * @param granularity as org.kitodo.production.model.bibliography.course.Granularity
&nbsp;     */
&nbsp;    public void setGranularity(Granularity granularity) {
<b class="nc">&nbsp;        this.granularity = granularity;</b>
<b class="nc">&nbsp;        course.splitInto(granularity);</b>
<b class="nc">&nbsp;        if (Objects.nonNull(PrimeFaces.current()) &amp;&amp; Objects.nonNull(FacesContext.getCurrentInstance())) {</b>
<b class="nc">&nbsp;            PrimeFaces.current().ajax().update(&quot;createProcessesConfirmDialog&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get array representing the months of a year.
&nbsp;     *
&nbsp;     * @return value of MONTHS
&nbsp;     */
&nbsp;    public static Integer[] getMonths() {
<b class="nc">&nbsp;        return MONTHS;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the currently displayed year.
&nbsp;     *
&nbsp;     * @return the year to be displayed as java.lang.String
&nbsp;     */
&nbsp;    public String getYear() {
<b class="nc">&nbsp;        return Integer.toString(yearShowing);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the currently displayed year.
&nbsp;     *
&nbsp;     * @param year to be displayed as java.lang.String
&nbsp;     */
&nbsp;    public void setYear(String year) {
<b class="nc">&nbsp;        yearShowing = Integer.parseInt(year);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Display the previous year in the calendar.
&nbsp;     */
&nbsp;    public void previousYear() {
<b class="nc">&nbsp;        yearShowing -= 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Display the next year in the calendar.
&nbsp;     */
&nbsp;    public void nextYear() {
<b class="nc">&nbsp;        yearShowing += 1;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get estimated number of pages per issue.
&nbsp;     *
&nbsp;     * @return value of numberOfPagesPerIssue
&nbsp;     */
&nbsp;    public int getNumberOfPagesPerIssue() {
<b class="nc">&nbsp;        return numberOfPagesPerIssue;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set estimated number of pages per issue.
&nbsp;     *
&nbsp;     * @param numberOfPagesPerIssue as int
&nbsp;     */
&nbsp;    public void setNumberOfPagesPerIssue(int numberOfPagesPerIssue) {
<b class="nc">&nbsp;        this.numberOfPagesPerIssue = numberOfPagesPerIssue;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the number of pages of every process for the chosen granularity.
&nbsp;     * Formatted as String with one decimal place.
&nbsp;     *
&nbsp;     * @return number of images as java.lang.String
&nbsp;     */
&nbsp;    public String getNumberOfPagesPerProcessFormatted() {
<b class="nc">&nbsp;        DecimalFormat decimalFormat = new DecimalFormat(&quot;#.#&quot;);</b>
<b class="nc">&nbsp;        return decimalFormat.format(getNumberOfPagesPerProcess());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the number of pages of every process for the chosen granularity.
&nbsp;     *
&nbsp;     * @return number of pages as long
&nbsp;     */
&nbsp;    public double getNumberOfPagesPerProcess() {
<b class="nc">&nbsp;        return course.countIndividualIssues() / ((double) Math.max(course.getNumberOfProcesses(), 1)) * numberOfPagesPerIssue;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The function checkBlockPlausibility compares the dates entered against
&nbsp;     * some plausibility assumptions and sets hints otherwise.
&nbsp;     */
&nbsp;    public void checkBlockPlausibility(Block block) {
<b class="nc">&nbsp;        LocalDate firstAppearance = block.getFirstAppearance();</b>
<b class="nc">&nbsp;        LocalDate lastAppearance = block.getLastAppearance();</b>
<b class="nc">&nbsp;        if (Objects.nonNull(firstAppearance) &amp;&amp; Objects.nonNull(lastAppearance)) {</b>
<b class="nc">&nbsp;            if (firstAppearance.plusYears(100).isBefore(lastAppearance)) {</b>
<b class="nc">&nbsp;                Helper.setMessage(BLOCK + &quot;long&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (firstAppearance.isAfter(lastAppearance)) {</b>
<b class="nc">&nbsp;                Helper.setErrorMessage(BLOCK_NEGATIVE);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (firstAppearance.isBefore(START_RELATION)) {</b>
<b class="nc">&nbsp;                Helper.setMessage(BLOCK + &quot;firstAppearance.early&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (firstAppearance.isAfter(today)) {</b>
<b class="nc">&nbsp;                Helper.setMessage(BLOCK + &quot;firstAppearance.fiction&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (lastAppearance.isBefore(START_RELATION)) {</b>
<b class="nc">&nbsp;                Helper.setMessage(BLOCK + &quot;lastAppearance.early&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (lastAppearance.isAfter(today)) {</b>
<b class="nc">&nbsp;                Helper.setMessage(BLOCK + &quot;lastAppearance.fiction&quot;);</b>
&nbsp;            }
<b class="nc">&nbsp;            this.setYear(String.valueOf(firstAppearance.getYear()));</b>
<b class="nc">&nbsp;            if (Objects.nonNull(PrimeFaces.current()) &amp;&amp; Objects.nonNull(FacesContext.getCurrentInstance())) {</b>
<b class="nc">&nbsp;                PrimeFaces.current().ajax().update(&quot;editForm:calendarTabView:calendarDetailsLayout&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Change whether the selected issue appeared on the selected date.
&nbsp;     * Depending on the regular interval of appearance this will change the additions and exclusions for this issue.
&nbsp;     *
&nbsp;     * @param selectedIssue issue to be modified
&nbsp;     * @param selectedDate date for which the issue will be modified
&nbsp;     */
&nbsp;    public void changeMatch(Issue selectedIssue, LocalDate selectedDate) {
<b class="nc">&nbsp;        if (selectedIssue.isMatch(selectedDate) &amp;&amp; selectedIssue.getAdditions().contains(selectedDate)) {</b>
<b class="nc">&nbsp;            selectedIssue.removeAddition(selectedDate);</b>
<b class="nc">&nbsp;        } else if (selectedIssue.isMatch(selectedDate) &amp;&amp; !selectedIssue.getAdditions().contains(selectedDate)) {</b>
<b class="nc">&nbsp;            selectedIssue.addExclusion(selectedDate);</b>
<b class="nc">&nbsp;        } else if (!selectedIssue.isMatch(selectedDate) &amp;&amp; selectedIssue.getExclusions().contains(selectedDate)) {</b>
<b class="nc">&nbsp;            selectedIssue.removeExclusion(selectedDate);</b>
<b class="nc">&nbsp;        } else if (!selectedIssue.isMatch(selectedDate) &amp;&amp; !selectedIssue.getExclusions().contains(selectedDate)) {</b>
<b class="nc">&nbsp;            selectedIssue.addAddition(selectedDate);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates and adds a copy of the currently
&nbsp;     * showing block.
&nbsp;     */
&nbsp;    public void copyBlock(Block block) {
<b class="nc">&nbsp;        Block copy = block.clone(course);</b>
<b class="nc">&nbsp;        LocalDate lastAppearance = course.getLastAppearance();</b>
<b class="nc">&nbsp;        if (Objects.nonNull(lastAppearance)) {</b>
<b class="nc">&nbsp;            LocalDate firstAppearance = lastAppearance.plusDays(1);</b>
<b class="nc">&nbsp;            copy.setFirstAppearance(firstAppearance);</b>
<b class="nc">&nbsp;            copy.setLastAppearance(firstAppearance);</b>
<b class="nc">&nbsp;            course.add(copy);</b>
<b class="nc">&nbsp;            navigate(copy);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The function is executed if the user clicks the action
&nbsp;     * link to “export” the calendar data. If the course of appearance doesn’t
&nbsp;     * yet contain generated processes—which is always the case, except that the
&nbsp;     * user just came from uploading a data file and didn’t change anything
&nbsp;     * about it—process data will be generated. Then an XML file will be made
&nbsp;     * out of it and sent to the user’s browser. If the granularity was
&nbsp;     * temporarily added, it will be removed afterwards so that the user will
&nbsp;     * not be presented with the option to generate processes “as imported” if
&nbsp;     * he or she never ran an import before.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Note: The process data will be generated with a granularity of “days”
&nbsp;     * (each day forms one process). This setting can be changed later after the
&nbsp;     * data has been re-imported, but it will remain if the user uploads the
&nbsp;     * saved data and then proceeds right to the next page and creates processes
&nbsp;     * with the granularity “as imported”. However, since this is possible
&nbsp;     * and—as to our knowledge in late 2014, when this was written—this is the
&nbsp;     * best option of all, this default has been chosen here.
&nbsp;     */
&nbsp;    public StreamedContent download() {
<b class="nc">&nbsp;        boolean granularityWasTemporarilyAdded = false;</b>
&nbsp;        try {
<b class="nc">&nbsp;            if (Objects.isNull(course) || course.countIndividualIssues() == 0) {</b>
<b class="nc">&nbsp;                Helper.setErrorMessage(&quot;errorDataIncomplete&quot;, &quot;calendar.isEmpty&quot;);</b>
<b class="nc">&nbsp;                return null;</b>
&nbsp;            }
<b class="nc">&nbsp;            if (course.getNumberOfProcesses() == 0) {</b>
<b class="nc">&nbsp;                granularityWasTemporarilyAdded = true;</b>
<b class="nc">&nbsp;                course.splitInto(Granularity.DAYS);</b>
&nbsp;            }
&nbsp;
<b class="nc">&nbsp;            byte[] data = XMLUtils.documentToByteArray(course.toXML(), 4);</b>
<b class="nc">&nbsp;            return DefaultStreamedContent.builder().stream(() -&gt; new ByteArrayInputStream(data))</b>
<b class="nc">&nbsp;                    .contentType(&quot;application/xml&quot;).name(&quot;newspaper.xml&quot;).build();</b>
<b class="nc">&nbsp;        } catch (TransformerException e) {</b>
<b class="nc">&nbsp;            Helper.setErrorMessage(&quot;granularity.download.error&quot;, &quot;errorTransformerException&quot;, logger, e);</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            Helper.setErrorMessage(&quot;granularity.download.error&quot;, e.getLocalizedMessage(), logger, e);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            if (granularityWasTemporarilyAdded) {</b>
<b class="nc">&nbsp;                course.clearProcesses();</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns whether the calendar editor is in mint
&nbsp;     * condition, i.e. there is no block defined yet, as read-only property
&nbsp;     * “blank”.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * Side note: “empty” is a reserved word in JSP and cannot be used as
&nbsp;     * property name.
&nbsp;     *
&nbsp;     * @return whether there is no block yet
&nbsp;     */
&nbsp;    public boolean getBlank() {
<b class="nc">&nbsp;        return course.isEmpty();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the data required to build the
&nbsp;     * calendar sheet as read-only property &quot;calendarSheet&quot;. The outer list
&nbsp;     * contains 31 entries, each representing a row of the calendar (the days
&nbsp;     * 1−31), each line then contains 12 cells representing the months. This is
&nbsp;     * due to HTML table being produced line by line.
&nbsp;     *
&nbsp;     * @return the table cells to build the calendar sheet
&nbsp;     */
&nbsp;    public List&lt;List&lt;Cell&gt;&gt; getCalendarSheet() {
<b class="nc">&nbsp;        List&lt;List&lt;Cell&gt;&gt; calendarSheet = getEmptySheet();</b>
<b class="nc">&nbsp;        populateByCalendar(calendarSheet);</b>
<b class="nc">&nbsp;        return calendarSheet;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The function will return the course created with this editor
&nbsp;     * as read-only property &quot;course&quot; to pass it to the next form.
&nbsp;     *
&nbsp;     * @return the course of appearance data model
&nbsp;     */
&nbsp;    public Course getCourse() {
<b class="nc">&nbsp;        return course;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds the empty calendar sheet with 31 rows
&nbsp;     * of twelve cells with empty objects of type Cell().
&nbsp;     *
&nbsp;     * @return an empty calendar sheet
&nbsp;     */
&nbsp;    private List&lt;List&lt;Cell&gt;&gt; getEmptySheet() {
<b class="nc">&nbsp;        List&lt;List&lt;Cell&gt;&gt; emptySheet = new ArrayList&lt;&gt;(31);</b>
<b class="nc">&nbsp;        for (int day = 1; day &lt;= 31; day++) {</b>
<b class="nc">&nbsp;            ArrayList&lt;Cell&gt; row = new ArrayList&lt;&gt;(12);</b>
<b class="nc">&nbsp;            for (int month = 1; month &lt;= 12; month++) {</b>
<b class="nc">&nbsp;                row.add(new Cell());</b>
&nbsp;            }
<b class="nc">&nbsp;            emptySheet.add(row);</b>
&nbsp;        }
<b class="nc">&nbsp;        return emptySheet;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The function is the getter method for the property
&nbsp;     * &quot;uploadedFile&quot; which is write-only, however Faces requires is.
&nbsp;     *
&nbsp;     * @return always null
&nbsp;     */
&nbsp;    public UploadedFile getUploadedFile() {
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Alters the year the calendar sheet is shown for so
&nbsp;     * that something of the current block is visible to prevent the user from
&nbsp;     * needing to click through centuries manually to get there.
&nbsp;     */
&nbsp;    protected void navigate(Block block) {
&nbsp;        try {
<b class="nc">&nbsp;            if (yearShowing &gt; block.getLastAppearance().getYear()) {</b>
<b class="nc">&nbsp;                yearShowing = block.getLastAppearance().getYear();</b>
&nbsp;            }
<b class="nc">&nbsp;            if (yearShowing &lt; block.getFirstAppearance().getYear()) {</b>
<b class="nc">&nbsp;                yearShowing = block.getFirstAppearance().getYear();</b>
&nbsp;            }
<b class="nc">&nbsp;        } catch (NullPointerException e) {</b>
<b class="nc">&nbsp;            Helper.setErrorMessage(e.getLocalizedMessage(), logger, e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Tries to interpret a string entered by the user as a date as flexible as
&nbsp;     * possible. Supports two-digit years and imperial date field order
&nbsp;     * (month/day/year). In case of flexible interpretations, hints will be
&nbsp;     * displayed to put the user on the right track what happened to his input.
&nbsp;     *
&nbsp;     * &lt;p&gt;
&nbsp;     * If the user clicks the link to upload a course of appearance file, no
&nbsp;     * warning message shall show. Therefore an alternate white-space character
&nbsp;     * (U+00A0) will be appended to the value string by Javascript on the user
&nbsp;     * side because the setter methods will be called by Faces before the link
&nbsp;     * action will be executed, but we want to skip the error message generation
&nbsp;     * in that case, too.
&nbsp;     *
&nbsp;     * @param value
&nbsp;     *            value entered by the user
&nbsp;     * @param input
&nbsp;     *            input element, one of &quot;firstAppearance&quot; or &quot;lastAppearance&quot;
&nbsp;     * @return the date if found, or null otherwise
&nbsp;     */
&nbsp;    private LocalDate parseDate(String value, String input) {
<b class="nc">&nbsp;        Matcher dateParser = FLEXIBLE_DATE.matcher(value);</b>
<b class="nc">&nbsp;        int[] numbers = new int[3];</b>
<b class="nc">&nbsp;        if (dateParser.matches()) {</b>
<b class="nc">&nbsp;            for (int i = 0; i &lt; 3; i++) {</b>
<b class="nc">&nbsp;                numbers[i] = Integer.parseInt(dateParser.group(i + 1));</b>
&nbsp;            }
<b class="nc">&nbsp;            if (numbers[2] &lt; 100) {</b>
<b class="nc">&nbsp;                numbers[2] += 100 * Math.floor((double) today.getYear() / 100);</b>
<b class="nc">&nbsp;                if (numbers[2] &gt; today.getYear()) {</b>
<b class="nc">&nbsp;                    numbers[2] -= 100;</b>
&nbsp;                }
<b class="nc">&nbsp;                Helper.setMessage(Helper.getTranslation(BLOCK + input + &quot;.yearCompleted&quot;,</b>
<b class="nc">&nbsp;                    dateParser.group(3), Integer.toString(numbers[2])));</b>
&nbsp;            }
&nbsp;            try {
<b class="nc">&nbsp;                return LocalDate.of(numbers[2], numbers[1], numbers[0]);</b>
<b class="nc">&nbsp;            } catch (DateTimeException invalidDate) {</b>
&nbsp;                try {
<b class="nc">&nbsp;                    LocalDate swapped = LocalDate.of(numbers[2], numbers[0], numbers[1]);</b>
<b class="nc">&nbsp;                    Helper.setMessage(BLOCK + input + &quot;.swapped&quot;);</b>
<b class="nc">&nbsp;                    return swapped;</b>
<b class="nc">&nbsp;                } catch (DateTimeException stillInvalid) {</b>
<b class="nc">&nbsp;                    Helper.setErrorMessage(invalidDate.getLocalizedMessage(), logger, stillInvalid);</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        if (!value.contains(&quot;\u00A0&quot;)) {</b>
<b class="nc">&nbsp;            Helper.setErrorMessage(BLOCK + input + &quot;.invalid&quot;);</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Populates an empty calendar sheet by
&nbsp;     * iterating on LocalDate.
&nbsp;     *
&nbsp;     * @param sheet
&nbsp;     *            calendar sheet to populate
&nbsp;     */
&nbsp;    protected void populateByCalendar(List&lt;List&lt;Cell&gt;&gt; sheet) {
<b class="nc">&nbsp;        Map&lt;Integer, List&lt;Issue&gt;&gt; issuesMap = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        Block currentBlock = null;</b>
<b class="nc">&nbsp;        LocalDate nextYear = LocalDate.of(yearShowing + 1, Month.JANUARY, 1);</b>
<b class="nc">&nbsp;        for (LocalDate date = LocalDate.of(yearShowing, Month.JANUARY, 1); date</b>
<b class="nc">&nbsp;                .isBefore(nextYear); date = date.plusDays(1)) {</b>
<b class="nc">&nbsp;            Cell cell = sheet.get(date.getDayOfMonth() - 1).get(date.getMonthValue() - 1);</b>
<b class="nc">&nbsp;            cell.setDate(date);</b>
<b class="nc">&nbsp;            if (Objects.isNull(currentBlock) || !currentBlock.isMatch(date)) {</b>
<b class="nc">&nbsp;                currentBlock = course.isMatch(date);</b>
&nbsp;            }
<b class="nc">&nbsp;            if (Objects.isNull(currentBlock)) {</b>
<b class="nc">&nbsp;                cell.setOnBlock(false);</b>
&nbsp;            } else {
<b class="nc">&nbsp;                Integer hashCode = currentBlock.hashCode();</b>
<b class="nc">&nbsp;                if (!issuesMap.containsKey(hashCode)) {</b>
<b class="nc">&nbsp;                    issuesMap.put(hashCode, currentBlock.getIssues());</b>
&nbsp;                }
<b class="nc">&nbsp;                cell.setIssues(issuesMap.get(hashCode));</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add a block to the course.
&nbsp;     */
&nbsp;    public void addBlock() {
<b class="nc">&nbsp;        course.add(new Block(course));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Remove block.
&nbsp;     *
&nbsp;     * @param block
&nbsp;     *          The Block to be removed from the course.
&nbsp;     */
&nbsp;    public void removeBlock(Block block) {
<b class="nc">&nbsp;        int index = course.indexOf(block);</b>
<b class="nc">&nbsp;        course.remove(block);</b>
<b class="nc">&nbsp;        if (index &gt; 0) {</b>
<b class="nc">&nbsp;            index--;</b>
&nbsp;        }
<b class="nc">&nbsp;        if (course.size() &gt; 0) {</b>
<b class="nc">&nbsp;            navigate(course.get(index));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add issue to given block.
&nbsp;     *
&nbsp;     * @param block block to add a new issue to
&nbsp;     */
&nbsp;    public void addIssue(Block block) {
<b class="nc">&nbsp;        if (Objects.nonNull(block)) {</b>
<b class="nc">&nbsp;            block.addIssue();</b>
<b class="nc">&nbsp;            block.checkIssuesWithSameHeading();</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the color from the list of defined colors for the given index.
&nbsp;     * These colors are used to highlight and distinguish the different issues in the calendar.
&nbsp;     *
&nbsp;     * @param index index to retrieve color for from list of colors
&nbsp;     * @return The color represented by a String containing the color&#39;s hex value
&nbsp;     */
&nbsp;    public String getIssueColor(int index) {
<b class="nc">&nbsp;        if (index &gt;= 0 &amp;&amp; index &lt; issueColours.length) {</b>
<b class="nc">&nbsp;            return issueColours[index];</b>
&nbsp;        }
<b class="nc">&nbsp;        return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * The method will be called by Faces to store the new
&nbsp;     * value of the read-write property &quot;uploadedFile&quot;, which is a reference to
&nbsp;     * the binary data the user provides for upload.
&nbsp;     *
&nbsp;     * @param data
&nbsp;     *            the UploadedFile object generated by the Tomahawk library
&nbsp;     */
&nbsp;    public void setUploadedFile(UploadedFile data) {
<b class="nc">&nbsp;        uploadedFile = data;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Upload an XML file to import a course of appearance.
&nbsp;     * Overrides the existing contents of course with the contents
&nbsp;     * of the XML file.
&nbsp;     */
&nbsp;    public void upload() {
&nbsp;        try {
<b class="nc">&nbsp;            if (Objects.isNull(uploadedFile)) {</b>
<b class="nc">&nbsp;                Helper.setMessage(UPLOAD_ERROR, &quot;calendar.upload.isEmpty&quot;);</b>
&nbsp;                return;
&nbsp;            }
<b class="nc">&nbsp;            Document xml = XMLUtils.load(uploadedFile.getInputStream());</b>
<b class="nc">&nbsp;            course = new Course(xml);</b>
<b class="nc">&nbsp;            Helper.removeManagedBean(&quot;GranularityForm&quot;);</b>
<b class="nc">&nbsp;            navigate(course.get(0));</b>
<b class="nc">&nbsp;        } catch (SAXException e) {</b>
<b class="nc">&nbsp;            Helper.setErrorMessage(UPLOAD_ERROR, &quot;errorSAXException&quot;, logger, e);</b>
<b class="nc">&nbsp;        } catch (IOException e) {</b>
<b class="nc">&nbsp;            Helper.setErrorMessage(UPLOAD_ERROR, e.getLocalizedMessage(), logger, e);</b>
<b class="nc">&nbsp;        } catch (IllegalArgumentException e) {</b>
<b class="nc">&nbsp;            Helper.setErrorMessage(&quot;calendar.upload.overlappingDateRanges&quot;, logger, e);</b>
<b class="nc">&nbsp;        } catch (NoSuchElementException e) {</b>
<b class="nc">&nbsp;            Helper.setErrorMessage(UPLOAD_ERROR, &quot;calendar.upload.missingMandatoryElement&quot;, logger, e);</b>
<b class="nc">&nbsp;        } catch (NullPointerException e) {</b>
<b class="nc">&nbsp;            Helper.setErrorMessage(&quot;calendar.upload.missingMandatoryValue&quot;, logger, e);</b>
&nbsp;        } finally {
<b class="nc">&nbsp;            uploadedFile = null;</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create processes for the modelled course of appearance and chosen granularity.
&nbsp;     */
&nbsp;    public String createProcesses() throws DAOException {
<b class="nc">&nbsp;        Process process = ServiceManager.getProcessService().getById(parentId);</b>
<b class="nc">&nbsp;        TaskManager.addTask(new GeneratesNewspaperProcessesThread(process, course));</b>
<b class="nc">&nbsp;        if (ServiceManager.getSecurityAccessService().hasAuthorityToViewTaskManagerPage()) {</b>
<b class="nc">&nbsp;            return TASK_MANAGER_REFERER;</b>
&nbsp;        }
<b class="nc">&nbsp;        return DEFAULT_REFERER;</b>
&nbsp;    }
&nbsp;
&nbsp;    public String formatString(String messageKey, String... replacements) {
<b class="nc">&nbsp;        return Helper.getTranslation(messageKey, replacements);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the first day of the year.
&nbsp;     * This might differ from January 1st as business years might have a different range of time.
&nbsp;     * The used PrimeFaces component requires a Date object including a specific year,
&nbsp;     * however the year is irrelevant for yearStart itself.
&nbsp;     *
&nbsp;     * @return Date representing the first day of the year
&nbsp;     */
&nbsp;    public Date getYearStart() {
<b class="nc">&nbsp;        Calendar calendar = new GregorianCalendar(</b>
<b class="nc">&nbsp;                today.getYear(), course.getYearStart().getMonth().ordinal(), course.getYearStart().getDayOfMonth());</b>
<b class="nc">&nbsp;        return calendar.getTime();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the first day of the year.
&nbsp;     * This might differ from January 1st as business years might have a different range of time.
&nbsp;     * The used PrimeFaces component passes a Date object including a specific year,
&nbsp;     * however the year is irrelevant for yearStart itself.
&nbsp;     *
&nbsp;     * @param date Date representing the first day of the year
&nbsp;     */
&nbsp;    public void setYearStart(Date date) {
<b class="nc">&nbsp;        if (Objects.nonNull(date)) {</b>
<b class="nc">&nbsp;            course.setYearStart(MonthDay.of(date.getMonth() + 1, date.getDate()));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the name of the year. The name of the year is optional and maybe
&nbsp;     * empty. Typical values are “Business year”, “Fiscal year”, or “Season”.
&nbsp;     *
&nbsp;     * @return the name of the year
&nbsp;     */
&nbsp;    public String getYearName() {
<b class="nc">&nbsp;        return course.getYearName();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Sets the year name of the course.
&nbsp;     *
&nbsp;     * @param yearName
&nbsp;     *            the yearName to set
&nbsp;     */
&nbsp;    public void setYearName(String yearName) {
<b class="nc">&nbsp;        course.setYearName(yearName);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get today.
&nbsp;     *
&nbsp;     * @return value of today
&nbsp;     */
&nbsp;    public LocalDate getToday() {
<b class="nc">&nbsp;        return today;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Add new metadata for the selected Block and with the selected date and Issue.
&nbsp;     */
&nbsp;    public void addMetadata(Issue issue, boolean onlyThisIssue) {
<b class="nc">&nbsp;        IndividualIssue selectedIssue = null;</b>
<b class="nc">&nbsp;        for (IndividualIssue individualIssue : getIndividualIssues(selectedBlock)) {</b>
<b class="nc">&nbsp;            if (Objects.nonNull(issue)</b>
<b class="nc">&nbsp;                    &amp;&amp; Objects.equals(individualIssue.getIssue(), issue)</b>
<b class="nc">&nbsp;                    &amp;&amp; Objects.equals(selectedDate, individualIssue.getDate())) {</b>
<b class="nc">&nbsp;                selectedIssue = individualIssue;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (!selectedBlock.getIssues().isEmpty() &amp;&amp; Objects.nonNull(selectedIssue)) {</b>
<b class="nc">&nbsp;            CountableMetadata metadata = new CountableMetadata(selectedBlock,</b>
<b class="nc">&nbsp;                    Triple.of(selectedIssue.getDate(), selectedIssue.getIssue(), onlyThisIssue));</b>
<b class="nc">&nbsp;            if (!metadata.getAllMetadataTypes().isEmpty()) {</b>
<b class="nc">&nbsp;                metadata.setMetadataDetail(metadata.getAllMetadataTypes().get(0));</b>
&nbsp;            }
<b class="nc">&nbsp;            selectedBlock.addMetadata(metadata);</b>
<b class="nc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            Helper.setErrorMessage(&quot;Selected issue or list of issues must not be empty for selectedBlock: &quot; + selectedBlock.toString());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get selectedDate.
&nbsp;     *
&nbsp;     * @return value of selectedDate
&nbsp;     */
&nbsp;    public LocalDate getSelectedDate() {
<b class="nc">&nbsp;        return selectedDate;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set selectedDate.
&nbsp;     *
&nbsp;     * @param selectedDate as java.time.LocalDate
&nbsp;     */
&nbsp;    public void setSelectedDate(LocalDate selectedDate) {
<b class="nc">&nbsp;        this.selectedDate = selectedDate;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get selectedBlock.
&nbsp;     *
&nbsp;     * @return value of selectedBlock
&nbsp;     */
&nbsp;    public Block getSelectedBlock() {
<b class="nc">&nbsp;        return selectedBlock;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the selected block based on the selected date.
&nbsp;     */
&nbsp;    public void setSelectedBlock() {
<b class="nc">&nbsp;        if (Objects.nonNull(selectedDate)) {</b>
<b class="nc">&nbsp;            for (Block block : course) {</b>
<b class="nc">&nbsp;                if ((block.getFirstAppearance().isBefore(selectedDate) || block.getFirstAppearance().isEqual(selectedDate))</b>
<b class="nc">&nbsp;                        &amp;&amp; (block.getLastAppearance().isAfter(selectedDate) || block.getLastAppearance().isEqual(selectedDate))) {</b>
<b class="nc">&nbsp;                    selectedBlock = block;</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set selectedBlock.
&nbsp;     *
&nbsp;     * @param selectedBlock as org.kitodo.production.model.bibliography.course.Block
&nbsp;     */
&nbsp;    public void setSelectedBlock(Block selectedBlock) {
<b class="nc">&nbsp;        this.selectedBlock = selectedBlock;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return a list of all individual issues for this block.
&nbsp;     *
&nbsp;     * @return the list of issues
&nbsp;     */
&nbsp;    public List&lt;IndividualIssue&gt; getIndividualIssues(Block block) {
<b class="nc">&nbsp;        return CalendarService.getIndividualIssues(block);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get list of metadata for given block on a specific date and issue.
&nbsp;     *
&nbsp;     * @param block the block to get the metadata from
&nbsp;     * @param date the date to get the metadata for
&nbsp;     * @param issue the issue to get the metadata for
&nbsp;     * @return list of matching metadata
&nbsp;     */
&nbsp;    public List&lt;CountableMetadata&gt; getMetadata(Block block, LocalDate date, Issue issue) {
<b class="nc">&nbsp;        return CalendarService.getMetadata(block, date, issue);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Set the issue and date where the given metadata occurred last.
&nbsp;     *
&nbsp;     * @param metadata the metadata to set the end date and issue for
&nbsp;     * @param date date where the metadata occurred last
&nbsp;     * @param issue issue where the metadata occurred last
&nbsp;     */
&nbsp;    public void setLastIssue(CountableMetadata metadata, LocalDate date, Issue issue) {
<b class="nc">&nbsp;        if (Objects.nonNull(metadata)) {</b>
<b class="nc">&nbsp;            metadata.setDelete(new ImmutablePair&lt;&gt;(date, issue));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get value of countable metadata for the given date and issue.
&nbsp;     *
&nbsp;     * @param metadata the metadata to calculate the the value for
&nbsp;     * @param date the date to calculate the value for
&nbsp;     * @param issue the issue to calculate the metadata for
&nbsp;     * @return the metadata value as java.lang.String
&nbsp;     */
&nbsp;    public String getTextMetadataValue(CountableMetadata metadata, LocalDate date, Issue issue) {
<b class="nc">&nbsp;        if (Objects.nonNull(metadata) &amp;&amp; metadata.getMetadataDetail() instanceof ProcessTextMetadata) {</b>
<b class="nc">&nbsp;            return metadata.getValue(new ImmutablePair&lt;&gt;(date, issue), course.getYearStart());</b>
&nbsp;        }
<b class="nc">&nbsp;        return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get all metadata of the given block as summary.
&nbsp;     * Each type of metadata is only listed once with its earliest occurrence.
&nbsp;     *
&nbsp;     * @param block the block to get the metadata for
&nbsp;     * @return list of pairs containing the metadata type and the date of its earliest occurrence
&nbsp;     */
&nbsp;    public List&lt;Pair&lt;ProcessDetail, LocalDate&gt;&gt; getMetadataSummary(Block block) {
<b class="nc">&nbsp;        return CalendarService.getMetadataSummary(block);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the value of the given processDetail.
&nbsp;     *
&nbsp;     * @param processDetail
&nbsp;     *            as ProcessDetail
&nbsp;     * @return the value as a java.lang.String
&nbsp;     */
&nbsp;    public String getMetadataValue(ProcessDetail processDetail) {
<b class="nc">&nbsp;        return ImportService.getProcessDetailValue(processDetail);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check if process with the same processtitle already exists.
&nbsp;     */
&nbsp;    public void checkDuplicatedTitles() throws ProcessGenerationException, DataException, DAOException,
&nbsp;            ConfigurationException, IOException, DoctypeMissingException {
<b class="nc">&nbsp;        if (course.parallelStream().noneMatch(block -&gt; Objects.equals(block.checkIssuesWithSameHeading(), true))) {</b>
<b class="nc">&nbsp;            Process process = ServiceManager.getProcessService().getById(parentId);</b>
<b class="nc">&nbsp;            NewspaperProcessesGenerator newspaperProcessesGenerator = new NewspaperProcessesGenerator(process, course);</b>
<b class="nc">&nbsp;            newspaperProcessesGenerator.initialize();</b>
<b class="nc">&nbsp;            if (!newspaperProcessesGenerator.isDuplicatedTitles()) {</b>
<b class="nc">&nbsp;                PrimeFaces.current().executeScript(&quot;PF(&#39;createProcessesConfirmDialog&#39;).show();&quot;);</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get first issue that&#39;s appear on the selected Date.
&nbsp;     * @return issue
&nbsp;     */
&nbsp;    public Issue getFirstMatchIssue() {
<b class="nc">&nbsp;        if (selectedDate != null) {</b>
<b class="nc">&nbsp;            return getCalendarSheet().get(selectedDate.getDayOfMonth() - 1).get(selectedDate.getMonthValue() - 1).getIssues()</b>
<b class="nc">&nbsp;                    .parallelStream()</b>
<b class="nc">&nbsp;                    .filter(issue -&gt; issue.isMatch(selectedDate))</b>
<b class="nc">&nbsp;                    .findFirst().orElse(null);</b>
&nbsp;        }
<b class="nc">&nbsp;        return null;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * add Metadata to all Issues that&#39;s appear on the selected Date.
&nbsp;     */
&nbsp;    public void addMetadataToAllMatchIssues() {
<b class="nc">&nbsp;        if (getFirstMatchIssue() != null) {</b>
<b class="nc">&nbsp;            addMetadata(getFirstMatchIssue(), false);</b>
&nbsp;        }
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-12 13:55</div>
</div>
</body>
</html>
