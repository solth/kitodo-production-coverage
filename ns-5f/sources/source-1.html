


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > FileService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.kitodo.production.services.file</a>
</div>

<h1>Coverage Summary for Class: FileService (org.kitodo.production.services.file)</h1>

<table class="coverageStats">
<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Class, %
</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FileService</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    65,9%
  </span>
  <span class="absValue">
    (56/85)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    42,3%
  </span>
  <span class="absValue">
    (165/390)
  </span>
</td>
</tr>

</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * (c) Kitodo. Key to digital objects e. V. &lt;contact@kitodo.org&gt;
&nbsp; *
&nbsp; * This file is part of the Kitodo project.
&nbsp; *
&nbsp; * It is licensed under GNU General Public License version 3 or later.
&nbsp; *
&nbsp; * For the full copyright and license information, please read the
&nbsp; * GPL3-License.txt file that was distributed with this source code.
&nbsp; */
&nbsp;
&nbsp;package org.kitodo.production.services.file;
&nbsp;
&nbsp;import java.io.File;
&nbsp;import java.io.FilenameFilter;
&nbsp;import java.io.IOException;
&nbsp;import java.io.InputStream;
&nbsp;import java.io.OutputStream;
&nbsp;import java.net.URI;
&nbsp;import java.net.URISyntaxException;
&nbsp;import java.nio.file.FileSystems;
&nbsp;import java.nio.file.Paths;
&nbsp;import java.text.MessageFormat;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collection;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.LinkedList;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Map.Entry;
&nbsp;import java.util.Objects;
&nbsp;import java.util.TreeMap;
&nbsp;import java.util.concurrent.TimeUnit;
&nbsp;import java.util.regex.Pattern;
&nbsp;
&nbsp;import org.apache.commons.io.FilenameUtils;
&nbsp;import org.apache.commons.lang3.StringUtils;
&nbsp;import org.apache.logging.log4j.LogManager;
&nbsp;import org.apache.logging.log4j.Logger;
&nbsp;import org.kitodo.api.command.CommandResult;
&nbsp;import org.kitodo.api.dataformat.LogicalDivision;
&nbsp;import org.kitodo.api.dataformat.MediaVariant;
&nbsp;import org.kitodo.api.dataformat.PhysicalDivision;
&nbsp;import org.kitodo.api.dataformat.View;
&nbsp;import org.kitodo.api.dataformat.Workpiece;
&nbsp;import org.kitodo.api.filemanagement.FileManagementInterface;
&nbsp;import org.kitodo.api.filemanagement.ProcessSubType;
&nbsp;import org.kitodo.config.ConfigCore;
&nbsp;import org.kitodo.config.enums.ParameterCore;
&nbsp;import org.kitodo.data.database.beans.Folder;
&nbsp;import org.kitodo.data.database.beans.Process;
&nbsp;import org.kitodo.data.database.beans.Ruleset;
&nbsp;import org.kitodo.data.database.beans.User;
&nbsp;import org.kitodo.data.database.exceptions.DAOException;
&nbsp;import org.kitodo.exceptions.CommandException;
&nbsp;import org.kitodo.exceptions.InvalidImagesException;
&nbsp;import org.kitodo.exceptions.MediaNotFoundException;
&nbsp;import org.kitodo.production.dto.ProcessDTO;
&nbsp;import org.kitodo.production.file.BackupFileRotation;
&nbsp;import org.kitodo.production.helper.Helper;
&nbsp;import org.kitodo.production.helper.metadata.ImageHelper;
&nbsp;import org.kitodo.production.helper.metadata.legacytypeimplementations.LegacyMetsModsDigitalDocumentHelper;
&nbsp;import org.kitodo.production.helper.metadata.pagination.Paginator;
&nbsp;import org.kitodo.production.metadata.MetadataEditor;
&nbsp;import org.kitodo.production.model.Subfolder;
&nbsp;import org.kitodo.production.services.ServiceManager;
&nbsp;import org.kitodo.production.services.command.CommandService;
&nbsp;import org.kitodo.production.services.data.RulesetService;
&nbsp;import org.kitodo.serviceloader.KitodoServiceLoader;
&nbsp;
<b class="fc">&nbsp;public class FileService {</b>
&nbsp;
<b class="fc">&nbsp;    private static final Logger logger = LogManager.getLogger(FileService.class);</b>
&nbsp;
<b class="fc">&nbsp;    private final MetadataImageComparator metadataImageComparator = new MetadataImageComparator(this);</b>
&nbsp;
&nbsp;    /**
&nbsp;     * Attachment to filename for the overall anchor file in Production v. 2.
&nbsp;     */
&nbsp;    private static final String APPENDIX_ANCOR = &quot;_anchor&quot;;
&nbsp;    /**
&nbsp;     * Attachment to filename for the year anchor file in Production v. 2.
&nbsp;     */
&nbsp;    private static final String APPENDIX_YEAR = &quot;_year&quot;;
&nbsp;    private static final String TEMPORARY_FILENAME_PREFIX = &quot;temporary_&quot;;
<b class="fc">&nbsp;    private final FileManagementInterface fileManagementModule = new KitodoServiceLoader&lt;&gt;(</b>
<b class="fc">&nbsp;            FileManagementInterface.class).loadModule();</b>
&nbsp;
&nbsp;    private static final String ARABIC = &quot;arabic&quot;;
&nbsp;    private static final String ROMAN = &quot;roman&quot;;
&nbsp;    private static final String ARABIC_DEFAULT_VALUE = &quot;1&quot;;
&nbsp;    private static final String ROMAN_DEFAULT_VALUE = &quot;I&quot;;
&nbsp;    private static final String UNCOUNTED_DEFAULT_VALUE = &quot; - &quot;;
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a slash to a URI to mark it as a directory, if it does not already
&nbsp;     * end with one.
&nbsp;     *
&nbsp;     * @param uri
&nbsp;     *            URI that you know to name a directory
&nbsp;     * @return URI, which definitely ends in a slash
&nbsp;     */
&nbsp;    public URI asDirectory(URI uri) {
<b class="fc">&nbsp;        String uriString = uri.toString();</b>
<b class="fc">&nbsp;        return uriString.endsWith(&quot;/&quot;) ? uri : URI.create(uriString.concat(&quot;/&quot;));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a MetaDirectory.
&nbsp;     *
&nbsp;     * @param parentFolderUri
&nbsp;     *            The URI, where the
&nbsp;     * @param directoryName
&nbsp;     *            the name of the directory
&nbsp;     * @return true or false
&nbsp;     * @throws IOException
&nbsp;     *             an IOException
&nbsp;     */
&nbsp;    URI createMetaDirectory(URI parentFolderUri, String directoryName) throws IOException, CommandException {
<b class="fc">&nbsp;        String encodedPath = &quot;&quot;;</b>
&nbsp;        try {
<b class="fc">&nbsp;            encodedPath = (new URI(null, null, directoryName, null)).toString();</b>
<b class="nc">&nbsp;        } catch (URISyntaxException e) {</b>
<b class="nc">&nbsp;            throw new IllegalArgumentException(e.getMessage(), e);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        URI directoryUri = asDirectory(parentFolderUri).resolve(encodedPath);</b>
<b class="fc">&nbsp;        if (fileExist(directoryUri)) {</b>
<b class="fc">&nbsp;            logger.info(&quot;Metadata directory: {} already existed! No new directory was created&quot;, directoryName);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            CommandService commandService = ServiceManager.getCommandService();</b>
<b class="fc">&nbsp;            String path = FileSystems.getDefault()</b>
<b class="fc">&nbsp;                    .getPath(ConfigCore.getKitodoDataDirectory(), parentFolderUri.getRawPath(), directoryName)</b>
<b class="fc">&nbsp;                    .normalize().toAbsolutePath().toString();</b>
<b class="fc">&nbsp;            List&lt;String&gt; commandParameter = Collections.singletonList(path);</b>
<b class="fc">&nbsp;            File script = new File(ConfigCore.getParameter(ParameterCore.SCRIPT_CREATE_DIR_META));</b>
<b class="fc">&nbsp;            if (!script.exists()) {</b>
<b class="nc">&nbsp;                throw new CommandException(Helper.getTranslation(&quot;fileNotFound&quot;, script.getName()));</b>
&nbsp;            }
<b class="fc">&nbsp;            CommandResult commandResult = commandService.runCommand(script, commandParameter);</b>
<b class="fc">&nbsp;            if (!commandResult.isSuccessful()) {</b>
<b class="nc">&nbsp;                String message = MessageFormat.format(</b>
&nbsp;                    &quot;Could not create directory {0} in {1}! No new directory was created&quot;, directoryName,
<b class="nc">&nbsp;                    parentFolderUri.getPath());</b>
<b class="nc">&nbsp;                logger.warn(message);</b>
<b class="nc">&nbsp;                throw new CommandException(message);</b>
&nbsp;            }
&nbsp;        }
<b class="fc">&nbsp;        return directoryUri;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generates the URI to the anchor file for Production v. 2 hierarchical
&nbsp;     * processes. This should not be used except for migration of legacy data.
&nbsp;     *
&nbsp;     * @param metadataFilePath
&nbsp;     *            path URI to meta XML file
&nbsp;     * @return path URI to anchor XML file
&nbsp;     */
&nbsp;    public URI createAnchorFile(URI metadataFilePath) {
<b class="fc">&nbsp;        return insertIntoURI(metadataFilePath, &quot;.xml&quot;, APPENDIX_ANCOR);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a directory including any missing parent directories.
&nbsp;     *
&nbsp;     * @param pathToCreate
&nbsp;     *            path to create
&nbsp;     */
&nbsp;    public void createDirectories(URI pathToCreate) throws IOException {
<b class="fc">&nbsp;        if (fileManagementModule.isDirectory(pathToCreate)) {</b>
&nbsp;            return;
&nbsp;        }
<b class="fc">&nbsp;        String path = pathToCreate.toString();</b>
<b class="fc">&nbsp;        int lastSlash = path.lastIndexOf(&#39;/&#39;);</b>
<b class="fc">&nbsp;        if (lastSlash &lt;= 0) {</b>
<b class="fc">&nbsp;            createDirectory(null, path);</b>
&nbsp;        } else {
<b class="fc">&nbsp;            URI before = URI.create(path.substring(0, lastSlash));</b>
<b class="fc">&nbsp;            String after = path.substring(lastSlash + 1);</b>
<b class="fc">&nbsp;            createDirectories(before);</b>
<b class="fc">&nbsp;            createDirectory(before, after);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a directory at a given URI with a given name.
&nbsp;     *
&nbsp;     * @param parentFolderUri
&nbsp;     *            the uri, where the directory should be created
&nbsp;     * @param directoryName
&nbsp;     *            the name of the directory.
&nbsp;     * @return the URI of the new directory or URI of parent directory if
&nbsp;     *         directoryName is null or empty
&nbsp;     */
&nbsp;    public URI createDirectory(URI parentFolderUri, String directoryName) throws IOException {
<b class="fc">&nbsp;        if (Objects.nonNull(directoryName)) {</b>
<b class="fc">&nbsp;            return fileManagementModule.create(parentFolderUri, directoryName, false);</b>
&nbsp;        }
<b class="nc">&nbsp;        return URI.create(&quot;&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a directory with a name given and assigns permissions to the
&nbsp;     * given user. Under Linux a script is used to set the file system
&nbsp;     * permissions accordingly. This cannot be done from within java code before
&nbsp;     * version 1.7.
&nbsp;     *
&nbsp;     * @param dirName
&nbsp;     *            Name of directory to create
&nbsp;     * @throws IOException
&nbsp;     *             If an I/O error occurs.
&nbsp;     */
&nbsp;    public void createDirectoryForUser(URI dirName, String userName) throws IOException {
<b class="fc">&nbsp;        if (!fileExist(dirName)) {</b>
<b class="fc">&nbsp;            CommandService commandService = ServiceManager.getCommandService();</b>
<b class="fc">&nbsp;            List&lt;String&gt; commandParameter = Arrays.asList(userName, new File(dirName).getAbsolutePath());</b>
<b class="fc">&nbsp;            commandService.runCommand(new File(ConfigCore.getParameter(ParameterCore.SCRIPT_CREATE_DIR_USER_HOME)),</b>
&nbsp;                commandParameter);
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates the folder structure needed for a process.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process
&nbsp;     * @return the URI to the process location
&nbsp;     */
&nbsp;    public URI createProcessLocation(Process process) throws IOException, CommandException {
<b class="fc">&nbsp;        URI processLocationUri = fileManagementModule.createProcessLocation(process.getId().toString());</b>
<b class="fc">&nbsp;        createProcessFolders(process, processLocationUri);</b>
<b class="fc">&nbsp;        return processLocationUri;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates the folders inside a process location.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process
&nbsp;     */
&nbsp;    public void createProcessFolders(Process process) throws IOException, CommandException {
<b class="fc">&nbsp;        createProcessFolders(process, fileManagementModule.createUriForExistingProcess(process.getId().toString()));</b>
&nbsp;    }
&nbsp;
&nbsp;    private void createProcessFolders(Process process, URI processLocationUri) throws IOException, CommandException {
<b class="fc">&nbsp;        for (Folder folder : process.getProject().getFolders()) {</b>
<b class="fc">&nbsp;            if (folder.isCreateFolder()) {</b>
<b class="fc">&nbsp;                URI parentFolderUri = processLocationUri;</b>
<b class="fc">&nbsp;                for (String singleFolder : new Subfolder(process, folder).getRelativeDirectoryPath()</b>
<b class="fc">&nbsp;                        .split(Pattern.quote(File.separator))) {</b>
<b class="fc">&nbsp;                    parentFolderUri = createMetaDirectory(parentFolderUri, singleFolder);</b>
&nbsp;                }
&nbsp;            }
<b class="fc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new File.
&nbsp;     *
&nbsp;     * @param fileName
&nbsp;     *            the name of the new file
&nbsp;     * @return the uri of the new file
&nbsp;     */
&nbsp;    public URI createResource(String fileName) throws IOException {
<b class="fc">&nbsp;        return fileManagementModule.create(null, fileName, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a resource at a given URI with a given name.
&nbsp;     *
&nbsp;     * @param targetFolder
&nbsp;     *            the URI of the target folder
&nbsp;     * @param name
&nbsp;     *            the name of the new resource
&nbsp;     * @return the URI of the created resource
&nbsp;     */
&nbsp;    public URI createResource(URI targetFolder, String name) throws IOException {
<b class="fc">&nbsp;        return fileManagementModule.create(targetFolder, name, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Generates the URI to the year file for Production v. 2 newspaper
&nbsp;     * processes. This should not be used except for migration of legacy data.
&nbsp;     *
&nbsp;     * @param metadataFilePath
&nbsp;     *            path URI to meta XML file
&nbsp;     * @return path URI to year XML file
&nbsp;     */
&nbsp;    public URI createYearFile(URI metadataFilePath) {
<b class="fc">&nbsp;        return insertIntoURI(metadataFilePath, &quot;.xml&quot;, APPENDIX_YEAR);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Inserts a string before another substring in an URI.
&nbsp;     *
&nbsp;     * @param uri
&nbsp;     *            URI to insert the string into
&nbsp;     * @param tail
&nbsp;     *            part of the URI before which the string is to be inserted
&nbsp;     * @param insert
&nbsp;     *            string to insert
&nbsp;     * @return URI with string inserted
&nbsp;     */
&nbsp;    private static URI insertIntoURI(URI uri, String tail, String insert) {
<b class="fc">&nbsp;        String data = uri.toASCIIString();</b>
<b class="fc">&nbsp;        int dataLength = data.length();</b>
<b class="fc">&nbsp;        int questionMark = data.indexOf(&#39;?&#39;);</b>
<b class="fc">&nbsp;        int resourceLength = questionMark &gt;= 0 ? questionMark : dataLength;</b>
<b class="fc">&nbsp;        if (questionMark &lt; 0) {</b>
<b class="fc">&nbsp;            int hash = data.indexOf(&#39;#&#39;);</b>
<b class="fc">&nbsp;            resourceLength = hash &gt;= 0 ? hash : dataLength;</b>
&nbsp;        }
<b class="fc">&nbsp;        int beforeTail = data.lastIndexOf(tail, resourceLength);</b>
<b class="fc">&nbsp;        int cutPosition = beforeTail &gt;= 0 ? beforeTail : resourceLength;</b>
<b class="fc">&nbsp;        String buffer = data.substring(0, cutPosition)</b>
&nbsp;                + insert
<b class="fc">&nbsp;                + data.substring(cutPosition, dataLength);</b>
<b class="fc">&nbsp;        return URI.create(buffer);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Writes to a file at a given URI.
&nbsp;     *
&nbsp;     * @param uri
&nbsp;     *            the URI, to write to.
&nbsp;     * @return an output stream to the file at the given URI or null
&nbsp;     */
&nbsp;    public OutputStream write(URI uri) throws IOException {
<b class="fc">&nbsp;        return fileManagementModule.write(uri);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Reads a file at a given URI.
&nbsp;     *
&nbsp;     * @param uri
&nbsp;     *            the uri to read
&nbsp;     * @return an InputStream to read from or null
&nbsp;     */
&nbsp;    public InputStream read(URI uri) throws IOException {
<b class="fc">&nbsp;        return fileManagementModule.read(uri);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Read metadata file (meta.xml).
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            for which file should be read
&nbsp;     * @return InputStream with metadata file
&nbsp;     */
&nbsp;    public InputStream readMetadataFile(Process process) throws IOException {
<b class="fc">&nbsp;        return read(getMetadataFilePath(process));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Read metadata file (meta.xml).
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            for which file should be read
&nbsp;     * @return InputStream with metadata file
&nbsp;     */
&nbsp;    public InputStream readMetadataFile(Process process, boolean forIndexingAll) throws IOException {
<b class="fc">&nbsp;        return read(getMetadataFilePath(process, true, forIndexingAll));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This function implements file renaming. Renaming of files is full of
&nbsp;     * mischief under Windows which unaccountably holds locks on files.
&nbsp;     * Sometimes running the JVM’s garbage collector puts things right.
&nbsp;     *
&nbsp;     * @param fileUri
&nbsp;     *            File to rename
&nbsp;     * @param newFileName
&nbsp;     *            New file name / destination
&nbsp;     * @throws IOException
&nbsp;     *             is thrown if renaming the file fails permanently
&nbsp;     */
&nbsp;    public URI renameFile(URI fileUri, String newFileName) throws IOException {
<b class="fc">&nbsp;        return fileManagementModule.rename(fileUri, newFileName);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculate all files with given file extension at specified directory
&nbsp;     * recursively.
&nbsp;     *
&nbsp;     * @param directory
&nbsp;     *            the directory to run through
&nbsp;     * @return number of files as Integer
&nbsp;     */
&nbsp;    public Integer getNumberOfFiles(URI directory) {
<b class="fc">&nbsp;        return fileManagementModule.getNumberOfFiles(null, directory);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Calculate all files with given file extension at specified directory
&nbsp;     * recursively.
&nbsp;     *
&nbsp;     * @param directory
&nbsp;     *            the directory to run through
&nbsp;     * @return number of files as Integer
&nbsp;     */
&nbsp;    public Integer getNumberOfImageFiles(URI directory) {
<b class="fc">&nbsp;        return fileManagementModule.getNumberOfFiles(ImageHelper.imageNameFilter, directory);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get size of directory.
&nbsp;     *
&nbsp;     * @param directory
&nbsp;     *            URI to get size
&nbsp;     * @return size of directory as Long
&nbsp;     */
&nbsp;    public Long getSizeOfDirectory(URI directory) throws IOException {
<b class="nc">&nbsp;        return fileManagementModule.getSizeOfDirectory(directory);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copy directory.
&nbsp;     *
&nbsp;     * @param sourceDirectory
&nbsp;     *            source file as uri
&nbsp;     * @param targetDirectory
&nbsp;     *            destination file as uri
&nbsp;     */
&nbsp;    public void copyDirectory(URI sourceDirectory, URI targetDirectory) throws IOException {
<b class="fc">&nbsp;        fileManagementModule.copy(sourceDirectory, targetDirectory);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copies a file from a given URI to a given URI.
&nbsp;     *
&nbsp;     * @param sourceUri
&nbsp;     *            the uri to copy from
&nbsp;     * @param destinationUri
&nbsp;     *            the uri to copy to
&nbsp;     * @throws IOException
&nbsp;     *             if copying fails
&nbsp;     */
&nbsp;    public void copyFile(URI sourceUri, URI destinationUri) throws IOException {
<b class="fc">&nbsp;        fileManagementModule.copy(sourceUri, destinationUri);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Copies a file to a directory.
&nbsp;     *
&nbsp;     * @param sourceDirectory
&nbsp;     *            The source directory
&nbsp;     * @param targetDirectory
&nbsp;     *            the target directory
&nbsp;     * @throws IOException
&nbsp;     *             if copying fails.
&nbsp;     */
&nbsp;    public void copyFileToDirectory(URI sourceDirectory, URI targetDirectory) throws IOException {
<b class="fc">&nbsp;        String target = targetDirectory.toString();</b>
<b class="fc">&nbsp;        if (!target.endsWith(&quot;/&quot;)) {</b>
<b class="fc">&nbsp;            targetDirectory = URI.create(target.concat(&quot;/&quot;));</b>
&nbsp;        }
<b class="fc">&nbsp;        fileManagementModule.copy(sourceDirectory, targetDirectory);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes a resource at a given URI.
&nbsp;     *
&nbsp;     * @param uri
&nbsp;     *            the uri to delete
&nbsp;     * @return true, if successful, false otherwise
&nbsp;     * @throws IOException
&nbsp;     *             if get of module fails
&nbsp;     */
&nbsp;    public boolean delete(URI uri) throws IOException {
<b class="fc">&nbsp;        return fileManagementModule.delete(uri);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks, if a file exists.
&nbsp;     *
&nbsp;     * @param uri
&nbsp;     *            the URI, to check, if there is a file
&nbsp;     * @return true, if the file exists
&nbsp;     */
&nbsp;    public boolean fileExist(URI uri) {
<b class="fc">&nbsp;        return fileManagementModule.fileExist(uri);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if a resource at a given URI is a file.
&nbsp;     *
&nbsp;     * @param uri
&nbsp;     *            the URI to check, if there is a file
&nbsp;     * @return true, if it is a file, false otherwise
&nbsp;     */
&nbsp;    public boolean isFile(URI uri) {
<b class="nc">&nbsp;        return fileManagementModule.isFile(uri);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * checks, if a URI leads to a directory.
&nbsp;     *
&nbsp;     * @param dir
&nbsp;     *            the uri to check.
&nbsp;     * @return true, if it is a directory.
&nbsp;     */
&nbsp;    public boolean isDirectory(URI dir) {
<b class="fc">&nbsp;        return fileManagementModule.isDirectory(dir);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks if an uri is readable.
&nbsp;     *
&nbsp;     * @param uri
&nbsp;     *            the uri to check.
&nbsp;     * @return true, if it&#39;s readable, false otherwise.
&nbsp;     */
&nbsp;    public boolean canRead(URI uri) {
<b class="nc">&nbsp;        return fileManagementModule.canRead(uri);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the name of a file at a given URI.
&nbsp;     *
&nbsp;     * @param uri
&nbsp;     *            the URI, to get the filename from.
&nbsp;     * @return the name of the file
&nbsp;     */
&nbsp;    public String getFileName(URI uri) {
<b class="fc">&nbsp;        return FilenameUtils.getBaseName(fileManagementModule.getFileNameWithExtension(uri));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the name of a file at a given uri.
&nbsp;     *
&nbsp;     * @param uri
&nbsp;     *            the URI, to get the filename from
&nbsp;     * @return the name of the file
&nbsp;     */
&nbsp;    public String getFileNameWithExtension(URI uri) {
<b class="fc">&nbsp;        return fileManagementModule.getFileNameWithExtension(uri);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Moves a directory from a given URI to a given URI.
&nbsp;     *
&nbsp;     * @param sourceUri
&nbsp;     *            the source URI
&nbsp;     * @param targetUri
&nbsp;     *            the target URI
&nbsp;     * @throws IOException
&nbsp;     *             if get of module fails
&nbsp;     */
&nbsp;    public void moveDirectory(URI sourceUri, URI targetUri) throws IOException {
<b class="fc">&nbsp;        fileManagementModule.move(sourceUri, targetUri);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Moves a file from a given URI to a given URI.
&nbsp;     *
&nbsp;     * @param sourceUri
&nbsp;     *            the source URI
&nbsp;     * @param targetUri
&nbsp;     *            the target URI
&nbsp;     * @throws IOException
&nbsp;     *             if get of module fails
&nbsp;     */
&nbsp;    public void moveFile(URI sourceUri, URI targetUri) throws IOException {
<b class="fc">&nbsp;        fileManagementModule.move(sourceUri, targetUri);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Process owns anchor XML.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            whose metadata file path to use
&nbsp;     * @return whether an anchor file was found
&nbsp;     * @throws IOException
&nbsp;     *             if Io failed
&nbsp;     */
&nbsp;    public boolean processOwnsAnchorXML(Process process) throws IOException {
<b class="nc">&nbsp;        URI yearFile = createAnchorFile(getMetadataFilePath(process, false, true));</b>
<b class="nc">&nbsp;        return fileExist(yearFile);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Process owns year XML.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            whose metadata file path to use
&nbsp;     * @return whether a year file was found
&nbsp;     * @throws IOException
&nbsp;     *             if Io failed
&nbsp;     */
&nbsp;    public boolean processOwnsYearXML(Process process) throws IOException {
<b class="nc">&nbsp;        URI yearFile = createYearFile(getMetadataFilePath(process, false, true));</b>
<b class="nc">&nbsp;        return fileExist(yearFile);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get all sub URIs of an URI.
&nbsp;     *
&nbsp;     * @param uri
&nbsp;     *            the URI, to get the sub URIs from
&nbsp;     * @return a List of sub URIs
&nbsp;     */
&nbsp;    public List&lt;URI&gt; getSubUris(URI uri) {
<b class="nc">&nbsp;        return fileManagementModule.getSubUris(null, uri);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get all sub URIs of an URI with a given filter.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            the filter to filter the sub URIs
&nbsp;     * @param uri
&nbsp;     *            the URI, to get the sub URIs from
&nbsp;     * @return a List of sub URIs
&nbsp;     */
&nbsp;    public List&lt;URI&gt; getSubUris(FilenameFilter filter, URI uri) {
<b class="fc">&nbsp;        return fileManagementModule.getSubUris(filter, uri);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Lists all Files at the given Path.
&nbsp;     *
&nbsp;     * @param file
&nbsp;     *            the directory to get the Files from
&nbsp;     * @return an Array of Files.
&nbsp;     */
&nbsp;    private File[] listFiles(File file) {
<b class="nc">&nbsp;        File[] unchecked = file.listFiles();</b>
<b class="nc">&nbsp;        return Objects.nonNull(unchecked) ? unchecked : new File[0];</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Writes a metadata file.
&nbsp;     *
&nbsp;     * @param gdzfile
&nbsp;     *            the file format
&nbsp;     * @param process
&nbsp;     *            the process
&nbsp;     * @throws IOException
&nbsp;     *             if error occurs
&nbsp;     */
&nbsp;    public void writeMetadataFile(LegacyMetsModsDigitalDocumentHelper gdzfile, Process process) throws IOException {
<b class="nc">&nbsp;        RulesetService rulesetService = ServiceManager.getRulesetService();</b>
&nbsp;        LegacyMetsModsDigitalDocumentHelper ff;
&nbsp;
<b class="nc">&nbsp;        Ruleset ruleset = process.getRuleset();</b>
<b class="nc">&nbsp;        ff = new LegacyMetsModsDigitalDocumentHelper(rulesetService.getPreferences(ruleset).getRuleset());</b>
&nbsp;
&nbsp;        // createBackupFile();
<b class="nc">&nbsp;        URI metadataFileUri = getMetadataFilePath(process, false, false);</b>
<b class="nc">&nbsp;        String temporaryMetadataFileName = getTemporaryMetadataFileName(metadataFileUri);</b>
&nbsp;
<b class="nc">&nbsp;        ff.setDigitalDocument(gdzfile.getDigitalDocument());</b>
&nbsp;        // ff.write(getMetadataFilePath());
<b class="nc">&nbsp;        ff.write(temporaryMetadataFileName);</b>
<b class="nc">&nbsp;        File temporaryMetadataFile = new File(temporaryMetadataFileName);</b>
<b class="nc">&nbsp;        boolean backupCondition = temporaryMetadataFile.exists() &amp;&amp; temporaryMetadataFile.length() &gt; 0;</b>
<b class="nc">&nbsp;        if (backupCondition) {</b>
<b class="nc">&nbsp;            createBackupFile(process);</b>
<b class="nc">&nbsp;            renameFile(Paths.get(temporaryMetadataFileName).toUri(), metadataFileUri.getRawPath());</b>
<b class="nc">&nbsp;            removePrefixFromRelatedMetsAnchorFilesFor(Paths.get(temporaryMetadataFileName).toUri());</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void removePrefixFromRelatedMetsAnchorFilesFor(URI temporaryMetadataFilename) throws IOException {
<b class="nc">&nbsp;        File temporaryFile = new File(temporaryMetadataFilename);</b>
<b class="nc">&nbsp;        File directoryPath = new File(temporaryFile.getParentFile().getPath());</b>
<b class="nc">&nbsp;        for (File temporaryAnchorFile : listFiles(directoryPath)) {</b>
<b class="nc">&nbsp;            String temporaryAnchorFileName = temporaryAnchorFile.toString();</b>
<b class="nc">&nbsp;            if (temporaryAnchorFile.isFile()</b>
<b class="nc">&nbsp;                    &amp;&amp; FilenameUtils.getBaseName(temporaryAnchorFileName).startsWith(TEMPORARY_FILENAME_PREFIX)) {</b>
<b class="nc">&nbsp;                String anchorFileName = FilenameUtils.concat(FilenameUtils.getFullPath(temporaryAnchorFileName),</b>
<b class="nc">&nbsp;                    temporaryAnchorFileName.replace(TEMPORARY_FILENAME_PREFIX, &quot;&quot;));</b>
<b class="nc">&nbsp;                temporaryAnchorFileName = FilenameUtils.concat(FilenameUtils.getFullPath(temporaryAnchorFileName),</b>
&nbsp;                    temporaryAnchorFileName);
<b class="nc">&nbsp;                renameFile(Paths.get(temporaryAnchorFileName).toUri(), new File(anchorFileName).toURI().getRawPath());</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a backup of {@code meta.xml}.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            process whose {@code meta.xml} shall be created a backup of.
&nbsp;     */
&nbsp;    public void createBackupFile(Process process) throws IOException {
&nbsp;        int numberOfBackups;
&nbsp;
<b class="fc">&nbsp;        numberOfBackups = ConfigCore.getIntParameter(ParameterCore.NUMBER_OF_META_BACKUPS);</b>
&nbsp;
<b class="fc">&nbsp;        if (numberOfBackups != ConfigCore.INT_PARAMETER_NOT_DEFINED_OR_ERRONEOUS) {</b>
<b class="fc">&nbsp;            BackupFileRotation bfr = new BackupFileRotation();</b>
<b class="fc">&nbsp;            bfr.setNumberOfBackups(numberOfBackups);</b>
<b class="fc">&nbsp;            bfr.setFormat(&quot;meta.*\\.xml&quot;);</b>
<b class="fc">&nbsp;            bfr.setProcess(process);</b>
<b class="fc">&nbsp;            bfr.performBackup();</b>
<b class="fc">&nbsp;        } else {</b>
<b class="nc">&nbsp;            logger.warn(&quot;No backup configured for meta data files.&quot;);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the URI of the metadata.xml of a given process.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process to get the metadata.xml for.
&nbsp;     * @return The URI to the metadata.xml
&nbsp;     */
&nbsp;    public URI getMetadataFilePath(Process process) throws IOException {
<b class="fc">&nbsp;        return getMetadataFilePath(process, true, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the URI of the metadata.xml of a given processDTO.
&nbsp;     *
&nbsp;     * @param processDTO
&nbsp;     *            the process to get the metadata.xml for.
&nbsp;     * @return The URI to the metadata.xml
&nbsp;     */
&nbsp;    public URI getMetadataFilePath(ProcessDTO processDTO) throws IOException {
<b class="nc">&nbsp;        return getMetadataFilePath(processDTO, true);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the URI of the metadata.xml of a given process.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process to get the metadata.xml for.
&nbsp;     * @param mustExist
&nbsp;     *            whether the file must exist
&nbsp;     * @return The URI to the metadata.xml
&nbsp;     */
&nbsp;    public URI getMetadataFilePath(Process process, boolean mustExist, boolean forIndexingAll) throws IOException {
<b class="fc">&nbsp;        URI metadataFilePath = getProcessSubTypeURI(process, ProcessSubType.META_XML, null, forIndexingAll);</b>
<b class="fc">&nbsp;        if (mustExist &amp;&amp; !fileExist(metadataFilePath)) {</b>
<b class="fc">&nbsp;            throw new IOException(Helper.getTranslation(&quot;metadataFileNotFound&quot;, metadataFilePath.getPath()));</b>
&nbsp;        }
<b class="fc">&nbsp;        return metadataFilePath;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the URI of the metadata.xml of a given processDTO.
&nbsp;     *
&nbsp;     * @param processDTO
&nbsp;     *            the process to get the metadata.xml for.
&nbsp;     * @param mustExist
&nbsp;     *            whether the file must exist
&nbsp;     * @return The URI to the metadata.xml
&nbsp;     */
&nbsp;    public URI getMetadataFilePath(ProcessDTO processDTO, boolean mustExist) throws IOException {
<b class="nc">&nbsp;        URI metadataFilePath = getProcessSubTypeURI(processDTO, ProcessSubType.META_XML, null);</b>
<b class="nc">&nbsp;        if (mustExist &amp;&amp; !fileExist(metadataFilePath)) {</b>
<b class="nc">&nbsp;            throw new IOException(Helper.getTranslation(&quot;metadataFileNotFound&quot;, metadataFilePath.getPath()));</b>
&nbsp;        }
<b class="nc">&nbsp;        return metadataFilePath;</b>
&nbsp;    }
&nbsp;
&nbsp;    private String getTemporaryMetadataFileName(URI fileName) {
<b class="nc">&nbsp;        File temporaryFile = getFile(fileName);</b>
<b class="nc">&nbsp;        String directoryPath = temporaryFile.getParentFile().getPath();</b>
<b class="nc">&nbsp;        String temporaryFileName = TEMPORARY_FILENAME_PREFIX + temporaryFile.getName();</b>
&nbsp;
<b class="nc">&nbsp;        return directoryPath + File.separator + temporaryFileName;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the specific IMAGE sub type.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process to get the imageDirectory for.
&nbsp;     * @return The uri of the Image Directory.
&nbsp;     */
&nbsp;    public URI getImagesDirectory(Process process) {
<b class="fc">&nbsp;        return getProcessSubTypeURI(process, ProcessSubType.IMAGE, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the URI to the ocr directory.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process tog et the ocr directory for.
&nbsp;     * @return the uri to the ocr directory.
&nbsp;     */
&nbsp;    public URI getOcrDirectory(Process process) {
<b class="fc">&nbsp;        return getProcessSubTypeURI(process, ProcessSubType.OCR, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the URI to the import directory.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process to get the import directory for.
&nbsp;     * @return the uri of the import directory
&nbsp;     */
&nbsp;    public URI getImportDirectory(Process process) {
<b class="fc">&nbsp;        return getProcessSubTypeURI(process, ProcessSubType.IMPORT, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the URI to the text directory.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process to get the text directory for.
&nbsp;     * @return the uri of the text directory
&nbsp;     */
&nbsp;    public URI getTxtDirectory(Process process) {
<b class="fc">&nbsp;        return getProcessSubTypeURI(process, ProcessSubType.OCR_TXT, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the URI to the pdf directory.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process to get the pdf directory for.
&nbsp;     * @return the uri of the pdf directory
&nbsp;     */
&nbsp;    public URI getPdfDirectory(Process process) {
<b class="fc">&nbsp;        return getProcessSubTypeURI(process, ProcessSubType.OCR_PDF, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the URI to the alto directory.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process to get the alto directory for.
&nbsp;     * @return the uri of the alto directory
&nbsp;     */
&nbsp;    public URI getAltoDirectory(Process process) {
<b class="fc">&nbsp;        return getProcessSubTypeURI(process, ProcessSubType.OCR_ALTO, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the URI to the word directory.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process to get the word directory for.
&nbsp;     * @return the uri of the word directory
&nbsp;     */
&nbsp;    public URI getWordDirectory(Process process) {
<b class="fc">&nbsp;        return getProcessSubTypeURI(process, ProcessSubType.OCR_WORD, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the URI to the template file.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process to get the template file for.
&nbsp;     * @return the uri of the template file
&nbsp;     */
&nbsp;    public URI getTemplateFile(Process process) {
<b class="fc">&nbsp;        return getProcessSubTypeURI(process, ProcessSubType.TEMPLATE, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the URI of the resource in the file management module for a URI
&nbsp;     * relative to the process directory.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            Process in whose possession the URI should be resolved
&nbsp;     * @param processRelativeUri
&nbsp;     *            URI relative to the specified process
&nbsp;     * @return URI of the resource
&nbsp;     */
&nbsp;    public URI getResourceUriForProcessRelativeUri(Process process, URI processRelativeUri) {
<b class="nc">&nbsp;        URI processBaseUri = getProcessBaseUriForExistingProcess(process);</b>
<b class="nc">&nbsp;        return asDirectory(processBaseUri).resolve(processRelativeUri);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method is needed for migration purposes. It maps existing filePaths
&nbsp;     * to the correct URI. File.separator doesn&#39;t work because on Windows it
&nbsp;     * appends backslash to URI.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process, the uri is needed for.
&nbsp;     * @return the URI.
&nbsp;     */
&nbsp;    public URI getProcessBaseUriForExistingProcess(Process process) {
<b class="fc">&nbsp;        URI processBaseUri = process.getProcessBaseUri();</b>
<b class="fc">&nbsp;        if (Objects.isNull(processBaseUri) &amp;&amp; Objects.nonNull(process.getId())) {</b>
<b class="fc">&nbsp;            process.setProcessBaseUri(fileManagementModule.createUriForExistingProcess(process.getId().toString()));</b>
&nbsp;        }
<b class="fc">&nbsp;        return process.getProcessBaseUri();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method is needed for migration purposes. It maps existing filePaths
&nbsp;     * to the correct URI. File.separator doesn&#39;t work because on Windows it
&nbsp;     * appends backslash to URI.
&nbsp;     *
&nbsp;     * @param processDTO
&nbsp;     *            the process, the uri is needed for.
&nbsp;     * @return the URI.
&nbsp;     */
&nbsp;    public String getProcessBaseUriForExistingProcess(ProcessDTO processDTO) {
<b class="nc">&nbsp;        String processBaseUri = processDTO.getProcessBaseUri();</b>
<b class="nc">&nbsp;        if (Objects.isNull(processBaseUri) &amp;&amp; Objects.nonNull(processDTO.getId())) {</b>
<b class="nc">&nbsp;            processDTO.setProcessBaseUri(fileManagementModule.createUriForExistingProcess(processDTO.getId().toString()).toString());</b>
&nbsp;        }
<b class="nc">&nbsp;        return processDTO.getProcessBaseUri();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get the URI for a process sub-location. Possible locations are listed in
&nbsp;     * ProcessSubType.
&nbsp;     *
&nbsp;     * @param processId
&nbsp;     *            the id of process to get the sublocation for
&nbsp;     * @param processTitle
&nbsp;     *            the title of process to get the sublocation for
&nbsp;     * @param processDataDirectory
&nbsp;     *            the base URI of process to get the sublocation for
&nbsp;     * @param processSubType
&nbsp;     *            The subType.
&nbsp;     * @param resourceName
&nbsp;     *            the name of the single object (e.g. image) if null, the root
&nbsp;     *            folder of the sublocation is returned
&nbsp;     * @return The URI of the requested location
&nbsp;     */
&nbsp;    public URI getProcessSubTypeURI(Integer processId, String processTitle, URI processDataDirectory,
&nbsp;            ProcessSubType processSubType, String resourceName) {
&nbsp;
<b class="fc">&nbsp;        if (Objects.isNull(processDataDirectory)) {</b>
&nbsp;            try {
<b class="nc">&nbsp;                Process process = ServiceManager.getProcessService().getById(processId);</b>
<b class="nc">&nbsp;                processDataDirectory = ServiceManager.getProcessService().getProcessDataDirectory(process);</b>
<b class="nc">&nbsp;            } catch (DAOException e) {</b>
<b class="nc">&nbsp;                processDataDirectory = URI.create(String.valueOf(processId));</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        if (Objects.isNull(resourceName)) {</b>
<b class="fc">&nbsp;            resourceName = &quot;&quot;;</b>
&nbsp;        }
<b class="fc">&nbsp;        return fileManagementModule.getProcessSubTypeUri(processDataDirectory, processTitle, processSubType,</b>
&nbsp;            resourceName);
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the URI for a Process Sub-location. Possible Locations are listed
&nbsp;     * in ProcessSubType
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process to get the sublocation for.
&nbsp;     * @param processSubType
&nbsp;     *            The subType.
&nbsp;     * @param resourceName
&nbsp;     *            the name of the single object (e.g. image) if null, the root
&nbsp;     *            folder of the sublocation is returned
&nbsp;     * @return The URI of the requested location
&nbsp;     */
&nbsp;    public URI getProcessSubTypeURI(Process process, ProcessSubType processSubType, String resourceName) {
<b class="fc">&nbsp;        return getProcessSubTypeURI(process, processSubType, resourceName, false);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the URI for a Process Sub-location. Possible Locations are listed
&nbsp;     * in ProcessSubType
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process to get the sublocation for.
&nbsp;     * @param processSubType
&nbsp;     *            The subType.
&nbsp;     * @param resourceName
&nbsp;     *            the name of the single object (e.g. image) if null, the root
&nbsp;     *            folder of the sublocation is returned
&nbsp;     * @return The URI of the requested location
&nbsp;     */
&nbsp;    private URI getProcessSubTypeURI(Process process, ProcessSubType processSubType, String resourceName,
&nbsp;            boolean forIndexingAll) {
&nbsp;
<b class="fc">&nbsp;        URI processDataDirectory = ServiceManager.getProcessService().getProcessDataDirectory(process, forIndexingAll);</b>
&nbsp;
<b class="fc">&nbsp;        if (Objects.isNull(resourceName)) {</b>
<b class="fc">&nbsp;            resourceName = &quot;&quot;;</b>
&nbsp;        }
<b class="fc">&nbsp;        return fileManagementModule.getProcessSubTypeUri(processDataDirectory,</b>
<b class="fc">&nbsp;            Helper.getNormalizedTitle(process.getTitle()), processSubType, resourceName);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the URI for a Process Sub-location. Possible Locations are listed
&nbsp;     * in ProcessSubType
&nbsp;     *
&nbsp;     * @param processDTO
&nbsp;     *            the process to get the sublocation for.
&nbsp;     * @param processSubType
&nbsp;     *            The subType.
&nbsp;     * @param resourceName
&nbsp;     *            the name of the single object (e.g. image) if null, the root
&nbsp;     *            folder of the sublocation is returned
&nbsp;     * @return The URI of the requested location
&nbsp;     */
&nbsp;    private URI getProcessSubTypeURI(ProcessDTO processDTO, ProcessSubType processSubType, String resourceName) {
&nbsp;
<b class="nc">&nbsp;        String processDataDirectory = ServiceManager.getProcessService().getProcessDataDirectory(processDTO);</b>
&nbsp;
<b class="nc">&nbsp;        if (Objects.isNull(resourceName)) {</b>
<b class="nc">&nbsp;            resourceName = &quot;&quot;;</b>
&nbsp;        }
<b class="nc">&nbsp;        return fileManagementModule.getProcessSubTypeUri(URI.create(processDataDirectory),</b>
<b class="nc">&nbsp;                Helper.getNormalizedTitle(processDTO.getTitle()), processSubType, resourceName);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get part of the URI for specific process.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            FilenameFilter object
&nbsp;     * @param processId
&nbsp;     *            the id of process
&nbsp;     * @param processTitle
&nbsp;     *            the title of process
&nbsp;     * @param processDataDirectory
&nbsp;     *            the base URI of process
&nbsp;     * @param processSubType
&nbsp;     *            object
&nbsp;     * @param resourceName
&nbsp;     *            as String
&nbsp;     * @return unmapped URI
&nbsp;     */
&nbsp;    public List&lt;URI&gt; getSubUrisForProcess(FilenameFilter filter, Integer processId, String processTitle,
&nbsp;            URI processDataDirectory, ProcessSubType processSubType, String resourceName) {
<b class="nc">&nbsp;        URI processSubTypeURI = getProcessSubTypeURI(processId, processTitle, processDataDirectory, processSubType,</b>
&nbsp;            resourceName);
<b class="nc">&nbsp;        return getSubUris(filter, processSubTypeURI);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get part of the URI for specific process.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            FilenameFilter object
&nbsp;     * @param process
&nbsp;     *            object
&nbsp;     * @param processSubType
&nbsp;     *            object
&nbsp;     * @param resourceName
&nbsp;     *            as String
&nbsp;     * @return unmapped URI
&nbsp;     */
&nbsp;    public List&lt;URI&gt; getSubUrisForProcess(FilenameFilter filter, Process process, ProcessSubType processSubType,
&nbsp;            String resourceName) {
<b class="nc">&nbsp;        URI processSubTypeURI = getProcessSubTypeURI(process, processSubType, resourceName);</b>
<b class="nc">&nbsp;        return getSubUris(filter, processSubTypeURI);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes all process directories and their content.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process to delete the directories for.
&nbsp;     * @return true, if deletion was successful.
&nbsp;     */
&nbsp;    public boolean deleteProcessContent(Process process) throws IOException {
<b class="nc">&nbsp;        for (ProcessSubType processSubType : ProcessSubType.values()) {</b>
<b class="nc">&nbsp;            URI processSubTypeURI = getProcessSubTypeURI(process, processSubType, null);</b>
<b class="nc">&nbsp;            if (!fileManagementModule.delete(processSubTypeURI)) {</b>
<b class="nc">&nbsp;                return false;</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        return true;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Gets the image source directory.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *            the process, to get the source directory for
&nbsp;     * @return the source directory as an URI
&nbsp;     */
&nbsp;    public URI getSourceDirectory(Process process) {
<b class="fc">&nbsp;        return getProcessSubTypeURI(process, ProcessSubType.IMAGE_SOURCE, null);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Searches for new media and adds them to the media list of the workpiece, if any are found.
&nbsp;     *
&nbsp;     * @param process
&nbsp;     *         Process in which folders should be searched for media
&nbsp;     * @param workpiece
&nbsp;     *         Workpiece to which the media are to be added
&nbsp;     */
&nbsp;    public boolean searchForMedia(Process process, Workpiece workpiece)
&nbsp;            throws InvalidImagesException, MediaNotFoundException {
<b class="fc">&nbsp;        final long begin = System.nanoTime();</b>
<b class="fc">&nbsp;        List&lt;Folder&gt; folders = process.getProject().getFolders();</b>
<b class="fc">&nbsp;        int mapCapacity = (int) Math.ceil(folders.size() / 0.75);</b>
<b class="fc">&nbsp;        Map&lt;String, Subfolder&gt; subfolders = new HashMap&lt;&gt;(mapCapacity);</b>
<b class="fc">&nbsp;        for (Folder folder : folders) {</b>
<b class="fc">&nbsp;            subfolders.put(folder.getFileGroup(), new Subfolder(process, folder));</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        Map&lt;String, Map&lt;Subfolder, URI&gt;&gt; currentMedia = new TreeMap&lt;&gt;(metadataImageComparator);</b>
<b class="fc">&nbsp;        for (Subfolder subfolder : subfolders.values()) {</b>
<b class="fc">&nbsp;            for (Entry&lt;String, URI&gt; element : subfolder.listContents(false).entrySet()) {</b>
<b class="nc">&nbsp;                currentMedia.computeIfAbsent(element.getKey(), any -&gt; new HashMap&lt;&gt;(mapCapacity));</b>
<b class="nc">&nbsp;                currentMedia.get(element.getKey()).put(subfolder, element.getValue());</b>
<b class="nc">&nbsp;            }</b>
<b class="fc">&nbsp;        }</b>
&nbsp;
<b class="fc">&nbsp;        List&lt;String&gt; canonicals = getCanonicalFileNamePartsAndSanitizeAbsoluteURIs(workpiece, subfolders,</b>
<b class="fc">&nbsp;                process.getProcessBaseUri());</b>
&nbsp;
<b class="fc">&nbsp;        if (currentMedia.size() == 0 &amp;&amp; canonicals.size() &gt; 0) {</b>
<b class="fc">&nbsp;            throw new MediaNotFoundException();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        addNewURIsToExistingPhysicalDivisions(currentMedia,</b>
<b class="nc">&nbsp;                workpiece.getAllPhysicalDivisionChildrenFilteredByTypePageAndSorted(), canonicals);</b>
<b class="nc">&nbsp;        Map&lt;String, Map&lt;Subfolder, URI&gt;&gt; mediaToAdd = new TreeMap&lt;&gt;(currentMedia);</b>
<b class="nc">&nbsp;        List&lt;String&gt; mediaToRemove = new LinkedList&lt;&gt;(canonicals);</b>
&nbsp;
<b class="nc">&nbsp;        mediaToRemove.removeAll(mediaToAdd.keySet());</b>
<b class="nc">&nbsp;        canonicals.forEach(mediaToAdd.keySet()::remove);</b>
<b class="nc">&nbsp;        removeMissingMediaFromWorkpiece(mediaToRemove, workpiece, subfolders.values());</b>
<b class="nc">&nbsp;        List&lt;PhysicalDivision&gt; children = workpiece.getPhysicalStructure().getChildren();</b>
<b class="nc">&nbsp;        boolean orderedChildren = (!children.isEmpty() &amp;&amp; children.get(0).getOrder() &gt; 0);</b>
<b class="nc">&nbsp;        addNewMediaToWorkpiece(canonicals, mediaToAdd, workpiece, orderedChildren);</b>
<b class="nc">&nbsp;        renumberPhysicalDivisions(workpiece, true);</b>
<b class="nc">&nbsp;        if (ConfigCore.getBooleanParameter(ParameterCore.WITH_AUTOMATIC_PAGINATION)) {</b>
<b class="nc">&nbsp;            repaginatePhysicalDivisions(workpiece);</b>
&nbsp;        }
<b class="nc">&nbsp;        if (Workpiece.treeStream(workpiece.getLogicalStructure())</b>
<b class="nc">&nbsp;                .allMatch(logicalDivision -&gt; logicalDivision.getViews().isEmpty())) {</b>
<b class="nc">&nbsp;            automaticallyAssignPhysicalDivisionsToEffectiveRootRecursive(workpiece, workpiece.getLogicalStructure());</b>
&nbsp;        }
<b class="nc">&nbsp;        if (logger.isTraceEnabled()) {</b>
<b class="nc">&nbsp;            logger.trace(&quot;Searching for media took {} ms&quot;, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - begin));</b>
&nbsp;        }
<b class="nc">&nbsp;        return orderedChildren &amp;&amp; !(mediaToAdd.isEmpty() &amp;&amp; mediaToRemove.isEmpty());</b>
&nbsp;    }
&nbsp;
&nbsp;    private void automaticallyAssignPhysicalDivisionsToEffectiveRootRecursive(Workpiece workpiece,
&nbsp;            LogicalDivision logicalDivision) {
&nbsp;
<b class="nc">&nbsp;        if (Objects.nonNull(logicalDivision.getType())) {</b>
<b class="nc">&nbsp;            Workpiece.treeStream(workpiece.getPhysicalStructure()).filter(physicalDivision -&gt; !physicalDivision.getMediaFiles().isEmpty())</b>
<b class="nc">&nbsp;                    .map(View::of).forEachOrdered(logicalDivision.getViews()::add);</b>
<b class="nc">&nbsp;        } else if (logicalDivision.getChildren().size() == 1) {</b>
<b class="nc">&nbsp;            automaticallyAssignPhysicalDivisionsToEffectiveRootRecursive(workpiece,</b>
<b class="nc">&nbsp;                logicalDivision.getChildren().get(0));</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parses the canonical part of the filename from the URIs of the media
&nbsp;     * units. Because we need to do this to be able to parse correctly, old
&nbsp;     * absolute URIs are converted to relative URIs.
&nbsp;     */
&nbsp;    private List&lt;String&gt; getCanonicalFileNamePartsAndSanitizeAbsoluteURIs(Workpiece workpiece,
&nbsp;            Map&lt;String, Subfolder&gt; subfolders, URI processBaseUri) throws InvalidImagesException {
&nbsp;
<b class="fc">&nbsp;        List&lt;String&gt; canonicals = new LinkedList&lt;&gt;();</b>
<b class="fc">&nbsp;        String baseUriString = processBaseUri.toString();</b>
<b class="fc">&nbsp;        if (!baseUriString.endsWith(&quot;/&quot;)) {</b>
<b class="fc">&nbsp;            baseUriString = baseUriString.concat(&quot;/&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        for (PhysicalDivision physicalDivision : workpiece.getAllPhysicalDivisionChildrenFilteredByTypePageAndSorted()) {</b>
<b class="fc">&nbsp;            String unitCanonical = &quot;&quot;;</b>
<b class="fc">&nbsp;            for (Entry&lt;MediaVariant, URI&gt; entry : physicalDivision.getMediaFiles().entrySet()) {</b>
<b class="fc">&nbsp;                Subfolder subfolder = subfolders.get(entry.getKey().getUse());</b>
<b class="fc">&nbsp;                if (Objects.isNull(subfolder)) {</b>
<b class="nc">&nbsp;                    logger.warn(&quot;Missing subfolder for USE {}&quot;, entry.getKey().getUse());</b>
<b class="nc">&nbsp;                    continue;</b>
&nbsp;                }
<b class="fc">&nbsp;                URI mediaFile = entry.getValue();</b>
<b class="fc">&nbsp;                String fileUriString = mediaFile.toString();</b>
<b class="fc">&nbsp;                if (fileUriString.startsWith(baseUriString)) {</b>
<b class="nc">&nbsp;                    mediaFile = URI.create(fileUriString.substring(baseUriString.length()));</b>
<b class="nc">&nbsp;                    physicalDivision.getMediaFiles().put(entry.getKey(), mediaFile);</b>
&nbsp;                }
<b class="fc">&nbsp;                String fileCanonical = subfolder.getCanonical(mediaFile);</b>
<b class="fc">&nbsp;                if (&quot;&quot;.equals(unitCanonical)) {</b>
<b class="fc">&nbsp;                    unitCanonical = fileCanonical;</b>
<b class="nc">&nbsp;                } else if (!unitCanonical.equals(fileCanonical)) {</b>
<b class="nc">&nbsp;                    throw new InvalidImagesException(&quot;Ambiguous canonical file name part in the same physical division: \&quot;&quot;</b>
&nbsp;                            + unitCanonical + &quot;\&quot; and \&quot;&quot; + fileCanonical + &quot;\&quot;!&quot;);
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            if (physicalDivision.getMediaFiles().size() &gt; 0 &amp;&amp; &quot;&quot;.equals(unitCanonical)) {</b>
<b class="nc">&nbsp;                throw new InvalidImagesException(&quot;Missing canonical file name part in physical division &quot; + physicalDivision);</b>
&nbsp;            }
<b class="fc">&nbsp;            canonicals.add(unitCanonical);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return canonicals;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds new media variants found to existing physical divisions.
&nbsp;     */
&nbsp;    private void addNewURIsToExistingPhysicalDivisions(Map&lt;String, Map&lt;Subfolder, URI&gt;&gt; mediaToAdd,
&nbsp;            List&lt;PhysicalDivision&gt; physicalDivisions, List&lt;String&gt; canonicals) {
&nbsp;
<b class="nc">&nbsp;        for (int i = 0; i &lt; canonicals.size(); i++) {</b>
<b class="nc">&nbsp;            String canonical = canonicals.get(i);</b>
<b class="nc">&nbsp;            PhysicalDivision physicalDivision = physicalDivisions.get(i);</b>
<b class="nc">&nbsp;            if (mediaToAdd.containsKey(canonical)) {</b>
<b class="nc">&nbsp;                for (Entry&lt;Subfolder, URI&gt; entry : mediaToAdd.get(canonical).entrySet()) {</b>
<b class="nc">&nbsp;                    physicalDivision.getMediaFiles().put(createMediaVariant(entry.getKey().getFolder()), entry.getValue());</b>
<b class="nc">&nbsp;                }</b>
&nbsp;            }
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private void removeMissingMediaFromWorkpiece(List&lt;String&gt; mediaToRemove, Workpiece workpiece,
&nbsp;                                                 Collection&lt;Subfolder&gt; subfolders) {
<b class="nc">&nbsp;        List&lt;PhysicalDivision&gt; pages = workpiece.getAllPhysicalDivisionChildrenFilteredByTypePageAndSorted();</b>
<b class="nc">&nbsp;        for (String removal : mediaToRemove) {</b>
<b class="nc">&nbsp;            if (StringUtils.isNotBlank(removal)) {</b>
<b class="nc">&nbsp;                for (PhysicalDivision page : pages) {</b>
<b class="nc">&nbsp;                    if (removal.equals(getCanonical(subfolders, page))) {</b>
<b class="nc">&nbsp;                        workpiece.getPhysicalStructure().getChildren().remove(page);</b>
<b class="nc">&nbsp;                        for (LogicalDivision structuralElement : page.getLogicalDivisions()) {</b>
<b class="nc">&nbsp;                            structuralElement.getViews().removeIf(view -&gt; view.getPhysicalDivision().equals(page));</b>
<b class="nc">&nbsp;                        }</b>
<b class="nc">&nbsp;                        page.getLogicalDivisions().clear();</b>
<b class="nc">&nbsp;                        LinkedList&lt;PhysicalDivision&gt; ancestors = MetadataEditor</b>
<b class="nc">&nbsp;                                .getAncestorsOfPhysicalDivision(page, workpiece.getPhysicalStructure());</b>
<b class="nc">&nbsp;                        if (!ancestors.isEmpty()) {</b>
<b class="nc">&nbsp;                            PhysicalDivision parent = ancestors.getLast();</b>
<b class="nc">&nbsp;                            parent.getChildren().remove(page);</b>
&nbsp;                        }
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (!mediaToRemove.isEmpty()) {</b>
<b class="nc">&nbsp;            int i = 1;</b>
<b class="nc">&nbsp;            for (PhysicalDivision division : workpiece.getAllPhysicalDivisionChildrenFilteredByTypePageAndSorted()) {</b>
<b class="nc">&nbsp;                division.setOrder(i);</b>
<b class="nc">&nbsp;                i++;</b>
<b class="nc">&nbsp;            }</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private String getCanonical(Collection&lt;Subfolder&gt; folders, PhysicalDivision division) {
<b class="nc">&nbsp;        Map&lt;MediaVariant, URI&gt; mediaFiles = division.getMediaFiles();</b>
<b class="nc">&nbsp;        for (Subfolder folder : folders) {</b>
<b class="nc">&nbsp;            for (URI mediaUri : mediaFiles.values()) {</b>
<b class="nc">&nbsp;                if (mediaUri.getPath().startsWith(folder.getFolder().getRelativePath())) {</b>
<b class="nc">&nbsp;                    String canonical = folder.getCanonical(mediaUri);</b>
<b class="nc">&nbsp;                    if (Objects.nonNull(canonical)) {</b>
<b class="nc">&nbsp;                        return canonical;</b>
&nbsp;                    }
&nbsp;                }
<b class="nc">&nbsp;            }</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds the new media to the workpiece. The media are sorted in according to
&nbsp;     * the canonical part of the file name.
&nbsp;     */
&nbsp;    private void addNewMediaToWorkpiece(List&lt;String&gt; canonicals, Map&lt;String, Map&lt;Subfolder, URI&gt;&gt; mediaToAdd,
&nbsp;            Workpiece workpiece, boolean orderedChildren) {
&nbsp;
<b class="nc">&nbsp;        LogicalDivision actualLogicalRoot = workpiece.getLogicalStructure();</b>
<b class="nc">&nbsp;        while (Objects.isNull(actualLogicalRoot.getType()) &amp;&amp; actualLogicalRoot.getChildren().size() == 1) {</b>
<b class="nc">&nbsp;            actualLogicalRoot = actualLogicalRoot.getChildren().get(0);</b>
&nbsp;        }
&nbsp;        // If the newspaper has multiple issues in the process, then everything stays as it was
<b class="nc">&nbsp;        if (Objects.isNull(actualLogicalRoot.getType()) &amp;&amp; actualLogicalRoot.getChildren().size() != 1) {</b>
<b class="nc">&nbsp;            actualLogicalRoot = workpiece.getLogicalStructure();</b>
&nbsp;        }
&nbsp;
<b class="nc">&nbsp;        for (Entry&lt;String, Map&lt;Subfolder, URI&gt;&gt; entry : mediaToAdd.entrySet()) {</b>
<b class="nc">&nbsp;            PhysicalDivision physicalDivision = createPhysicalDivision(entry.getValue());</b>
<b class="nc">&nbsp;            View view = new View();</b>
<b class="nc">&nbsp;            view.setPhysicalDivision(physicalDivision);</b>
&nbsp;            // do not use canonical filename parts if existing physical structures already have &quot;order&quot; values &gt; 0!
<b class="nc">&nbsp;            if (orderedChildren) {</b>
<b class="nc">&nbsp;                physicalDivision.setOrder(workpiece.getPhysicalStructure().getChildren().size());</b>
<b class="nc">&nbsp;                workpiece.getPhysicalStructure().getChildren().add(physicalDivision);</b>
<b class="nc">&nbsp;                actualLogicalRoot.getViews().add(view);</b>
<b class="nc">&nbsp;                view.getPhysicalDivision().getLogicalDivisions().add(actualLogicalRoot);</b>
<b class="nc">&nbsp;                canonicals.add(entry.getKey());</b>
&nbsp;            } else {
&nbsp;                // only use canonical filename parts if no ordered physical structures exist in the workpiece, yet
<b class="nc">&nbsp;                int insertionPoint = 0;</b>
<b class="nc">&nbsp;                for (String canonical : canonicals) {</b>
<b class="nc">&nbsp;                    if (metadataImageComparator.compare(entry.getKey(), canonical) &gt; 0) {</b>
<b class="nc">&nbsp;                        insertionPoint++;</b>
&nbsp;                    } else {
&nbsp;                        break;
&nbsp;                    }
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                workpiece.getPhysicalStructure().getChildren().add(insertionPoint, physicalDivision);</b>
<b class="nc">&nbsp;                actualLogicalRoot.getViews().add(insertionPoint, view);</b>
<b class="nc">&nbsp;                view.getPhysicalDivision().getLogicalDivisions().add(actualLogicalRoot);</b>
<b class="nc">&nbsp;                canonicals.add(insertionPoint, entry.getKey());</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new physical division with the given uses and URIs.
&nbsp;     */
&nbsp;    private PhysicalDivision createPhysicalDivision(Map&lt;Subfolder, URI&gt; data) {
<b class="nc">&nbsp;        PhysicalDivision physicalDivision = new PhysicalDivision();</b>
<b class="nc">&nbsp;        if (!data.entrySet().isEmpty()) {</b>
<b class="nc">&nbsp;            physicalDivision.setType(PhysicalDivision.TYPE_PAGE);</b>
&nbsp;        }
<b class="nc">&nbsp;        for (Entry&lt;Subfolder, URI&gt; entry : data.entrySet()) {</b>
<b class="nc">&nbsp;            Folder folder = entry.getKey().getFolder();</b>
<b class="nc">&nbsp;            MediaVariant mediaVariant = createMediaVariant(folder);</b>
<b class="nc">&nbsp;            physicalDivision.getMediaFiles().put(mediaVariant, entry.getValue());</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return physicalDivision;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a new media variant for the given use.
&nbsp;     */
&nbsp;    private MediaVariant createMediaVariant(Folder folder) {
<b class="nc">&nbsp;        MediaVariant mediaVariant = new MediaVariant();</b>
<b class="nc">&nbsp;        mediaVariant.setUse(folder.getFileGroup());</b>
<b class="nc">&nbsp;        mediaVariant.setMimeType(folder.getMimeType());</b>
<b class="nc">&nbsp;        return mediaVariant;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Renumbers the order of the physical divisions.
&nbsp;     */
&nbsp;    public void renumberPhysicalDivisions(Workpiece workpiece, boolean sortByOrder) {
<b class="nc">&nbsp;        int order = 1;</b>
<b class="nc">&nbsp;        for (PhysicalDivision physicalDivision : sortByOrder ? workpiece.getAllPhysicalDivisionChildrenFilteredByTypePageAndSorted()</b>
<b class="nc">&nbsp;                : workpiece.getPhysicalStructure().getAllChildren()) {</b>
<b class="nc">&nbsp;            physicalDivision.setOrder(order++);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Adds a count to media that do not yet have a count. But only at the end,
&nbsp;     * or if none of the media has been counted yet at all. New media found in
&nbsp;     * intermediate places are marked uncounted.
&nbsp;     */
&nbsp;    private void repaginatePhysicalDivisions(Workpiece workpiece) {
<b class="nc">&nbsp;        List&lt;PhysicalDivision&gt; physicalDivisions = workpiece.getAllPhysicalDivisionChildrenFilteredByTypePageAndSorted();</b>
<b class="nc">&nbsp;        int first = 0;</b>
&nbsp;        String value;
<b class="nc">&nbsp;        switch (ConfigCore.getParameter(ParameterCore.METS_EDITOR_DEFAULT_PAGINATION)) {</b>
&nbsp;            case ARABIC:
<b class="nc">&nbsp;                value = ARABIC_DEFAULT_VALUE;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case ROMAN:
<b class="nc">&nbsp;                value = ROMAN_DEFAULT_VALUE;</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
<b class="nc">&nbsp;                value = UNCOUNTED_DEFAULT_VALUE;</b>
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        if (!UNCOUNTED_DEFAULT_VALUE.equals(value)) {</b>
<b class="nc">&nbsp;            for (int i = physicalDivisions.size() - 1; i &gt;= 0; i--) {</b>
<b class="nc">&nbsp;                PhysicalDivision physicalDivision = physicalDivisions.get(i);</b>
<b class="nc">&nbsp;                String orderlabel = physicalDivision.getOrderlabel();</b>
<b class="nc">&nbsp;                if (Objects.nonNull(orderlabel) &amp;&amp; !physicalDivision.getMediaFiles().isEmpty()) {</b>
<b class="nc">&nbsp;                    first = i + 1;</b>
<b class="nc">&nbsp;                    value = orderlabel;</b>
<b class="nc">&nbsp;                    physicalDivisions.get(i).setType(PhysicalDivision.TYPE_PAGE);</b>
<b class="nc">&nbsp;                    break;</b>
&nbsp;                }
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        Paginator paginator = new Paginator(value);</b>
<b class="nc">&nbsp;        if (first &gt; 0) {</b>
<b class="nc">&nbsp;            paginator.next();</b>
<b class="nc">&nbsp;            for (int i = first; i &lt; physicalDivisions.size(); i++) {</b>
<b class="nc">&nbsp;                physicalDivisions.get(i).setOrderlabel(paginator.next());</b>
&nbsp;            }
&nbsp;        }
<b class="nc">&nbsp;        for (PhysicalDivision physicalDivision : physicalDivisions) {</b>
<b class="nc">&nbsp;            if (Objects.isNull(physicalDivision.getOrderlabel())) {</b>
<b class="nc">&nbsp;                physicalDivision.setOrderlabel(UNCOUNTED_DEFAULT_VALUE);</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
&nbsp;    }
&nbsp;
&nbsp;    public void writeMetadataAsTemplateFile(LegacyMetsModsDigitalDocumentHelper inFile, Process process)
&nbsp;            throws IOException {
<b class="nc">&nbsp;        inFile.write(getTemplateFile(process).toString());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Creates a symbolic link.
&nbsp;     *
&nbsp;     * @param targetUri
&nbsp;     *            the target URI for the link
&nbsp;     * @param homeUri
&nbsp;     *            the home URI
&nbsp;     * @return true, if link creation was successful
&nbsp;     */
&nbsp;    public boolean createSymLink(URI homeUri, URI targetUri, boolean onlyRead, User user) {
<b class="fc">&nbsp;        return fileManagementModule.createSymLink(homeUri, targetUri, onlyRead, user.getLogin());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Delete a symbolic link.
&nbsp;     *
&nbsp;     * @param homeUri
&nbsp;     *            the URI of the home folder, where the link should be deleted
&nbsp;     * @return true, if deletion was successful
&nbsp;     */
&nbsp;    public boolean deleteSymLink(URI homeUri) {
<b class="fc">&nbsp;        return fileManagementModule.deleteSymLink(homeUri);</b>
&nbsp;    }
&nbsp;
&nbsp;    public File getFile(URI uri) {
<b class="fc">&nbsp;        return fileManagementModule.getFile(uri);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Deletes the slash as first character from an uri object.
&nbsp;     *
&nbsp;     * @param uri
&nbsp;     *            The uri object.
&nbsp;     * @return The new uri object without first slash.
&nbsp;     */
&nbsp;    public URI deleteFirstSlashFromPath(URI uri) {
<b class="fc">&nbsp;        String uriString = uri.getPath();</b>
<b class="fc">&nbsp;        if (uriString.startsWith(&quot;/&quot;)) {</b>
<b class="fc">&nbsp;            uriString = uriString.replaceFirst(&quot;/&quot;, &quot;&quot;);</b>
&nbsp;        }
<b class="fc">&nbsp;        return URI.create(uriString);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Check and return whether given process has an empty generator folder or not.
&nbsp;     *
&nbsp;     * @param process Process
&nbsp;     * @param generatorSource Folder
&nbsp;     * @return whether given URI points to empty directory or not
&nbsp;     * @throws IOException thrown if listing contents of given URI is not possible
&nbsp;     */
&nbsp;    public static boolean hasImages(Process process, Folder generatorSource) throws IOException, DAOException {
<b class="nc">&nbsp;        if (Objects.nonNull(generatorSource)) {</b>
<b class="nc">&nbsp;            Subfolder sourceFolder = new Subfolder(process, generatorSource);</b>
<b class="nc">&nbsp;            return !sourceFolder.listContents().isEmpty();</b>
&nbsp;        }
<b class="nc">&nbsp;        return false;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Returns the comparator for metadata images.
&nbsp;     *
&nbsp;     * @return comparator for metadata images
&nbsp;     */
&nbsp;    public MetadataImageComparator getMetadataImageComparator() {
<b class="fc">&nbsp;        return metadataImageComparator;</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-12 13:55</div>
</div>
</body>
</html>
