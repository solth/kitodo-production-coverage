


<!DOCTYPE html>
<html id="htmlId">
<head>
  <title>Coverage Report > FilterService</title>
  <style type="text/css">
    @import "../../css/coverage.css";
    @import "../../css/idea.min.css";
  </style>
  <script type="text/javascript" src="../../js/highlight.min.js"></script>
  <script type="text/javascript" src="../../js/highlightjs-line-numbers.min.js"></script>
</head>

<body>
<div class="content">
<div class="breadCrumbs">
Current scope:     <a href="../../index.html">all classes</a>
    <span class="separator">|</span>
    <a href="../index.html">org.kitodo.production.services.data</a>
</div>

<h1>Coverage Summary for Class: FilterService (org.kitodo.production.services.data)</h1>

<table class="coverageStats">

<tr>
  <th class="name">Class</th>
<th class="coverageStat 
">
  Method, %
</th>
<th class="coverageStat 
">
  Line, %
</th>
</tr>
<tr>
  <td class="name">FilterService</td>
<td class="coverageStat">
  <span class="percent">
    57,9%
  </span>
  <span class="absValue">
    (33/57)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    48,1%
  </span>
  <span class="absValue">
    (190/395)
  </span>
</td>
</tr>
  <tr>
    <td class="name">FilterService$1</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
  </tr>
  <tr>
    <td class="name">FilterService$TaskFilter</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (1/1)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    100%
  </span>
  <span class="absValue">
    (7/7)
  </span>
</td>
  </tr>
<tr>
  <td class="name"><strong>Total</strong></td>
<td class="coverageStat">
  <span class="percent">
    59,3%
  </span>
  <span class="absValue">
    (35/59)
  </span>
</td>
<td class="coverageStat">
  <span class="percent">
    49,1%
  </span>
  <span class="absValue">
    (198/403)
  </span>
</td>
</tr>
</table>

<br/>
<br/>


<pre>
<code class="sourceCode" id="sourceCode">&nbsp;/*
&nbsp; * (c) Kitodo. Key to digital objects e. V. &lt;contact@kitodo.org&gt;
&nbsp; *
&nbsp; * This file is part of the Kitodo project.
&nbsp; *
&nbsp; * It is licensed under GNU General Public License version 3 or later.
&nbsp; *
&nbsp; * For the full copyright and license information, please read the
&nbsp; * GPL3-License.txt file that was distributed with this source code.
&nbsp; */
&nbsp;
&nbsp;package org.kitodo.production.services.data;
&nbsp;
&nbsp;import java.lang.reflect.Field;
&nbsp;import java.util.ArrayList;
&nbsp;import java.util.Arrays;
&nbsp;import java.util.Collections;
&nbsp;import java.util.HashMap;
&nbsp;import java.util.HashSet;
&nbsp;import java.util.List;
&nbsp;import java.util.Map;
&nbsp;import java.util.Objects;
&nbsp;import java.util.Set;
&nbsp;import java.util.StringTokenizer;
&nbsp;import java.util.function.Predicate;
&nbsp;import java.util.regex.Pattern;
&nbsp;import java.util.stream.Collectors;
&nbsp;import java.util.stream.IntStream;
&nbsp;
&nbsp;import org.apache.commons.lang3.StringUtils;
&nbsp;import org.apache.logging.log4j.LogManager;
&nbsp;import org.apache.logging.log4j.Logger;
&nbsp;import org.elasticsearch.index.query.BoolQueryBuilder;
&nbsp;import org.elasticsearch.index.query.Operator;
&nbsp;import org.elasticsearch.index.query.QueryBuilder;
&nbsp;import org.elasticsearch.index.query.QueryBuilders;
&nbsp;import org.kitodo.config.ConfigCore;
&nbsp;import org.kitodo.config.enums.ParameterCore;
&nbsp;import org.kitodo.data.database.beans.Filter;
&nbsp;import org.kitodo.data.database.beans.Role;
&nbsp;import org.kitodo.data.database.beans.User;
&nbsp;import org.kitodo.data.database.enums.TaskStatus;
&nbsp;import org.kitodo.data.database.exceptions.DAOException;
&nbsp;import org.kitodo.data.database.persistence.FilterDAO;
&nbsp;import org.kitodo.data.elasticsearch.index.Indexer;
&nbsp;import org.kitodo.data.elasticsearch.index.type.FilterType;
&nbsp;import org.kitodo.data.elasticsearch.index.type.enums.FilterTypeField;
&nbsp;import org.kitodo.data.elasticsearch.index.type.enums.TaskTypeField;
&nbsp;import org.kitodo.data.elasticsearch.search.Searcher;
&nbsp;import org.kitodo.data.elasticsearch.search.enums.SearchCondition;
&nbsp;import org.kitodo.data.exceptions.DataException;
&nbsp;import org.kitodo.production.dto.BaseDTO;
&nbsp;import org.kitodo.production.dto.FilterDTO;
&nbsp;import org.kitodo.production.dto.ProcessDTO;
&nbsp;import org.kitodo.production.dto.ProjectDTO;
&nbsp;import org.kitodo.production.dto.TaskDTO;
&nbsp;import org.kitodo.production.enums.FilterString;
&nbsp;import org.kitodo.production.enums.ObjectType;
&nbsp;import org.kitodo.production.helper.Helper;
&nbsp;import org.kitodo.production.services.ServiceManager;
&nbsp;import org.kitodo.production.services.data.base.SearchService;
&nbsp;import org.primefaces.model.SortOrder;
&nbsp;
&nbsp;/**
&nbsp; * Service for Filter bean.
&nbsp; */
&nbsp;public class FilterService extends SearchService&lt;Filter, FilterDTO, FilterDAO&gt; {
&nbsp;
<b class="fc">&nbsp;    private static final Logger logger = LogManager.getLogger(FilterService.class);</b>
<b class="fc">&nbsp;    private static volatile FilterService instance = null;</b>
&nbsp;    
<b class="fc">&nbsp;    private static final Pattern CONDITION_PATTERN = Pattern.compile(&quot;\\(([^\\)]+)\\)|([^\\(\\)\\|]+)&quot;);</b>
&nbsp;    public static final String FILTER_STRING = &quot;filterString&quot;;
&nbsp;
&nbsp;    /**
&nbsp;     * Constructor with Searcher and Indexer assigning.
&nbsp;     */
&nbsp;    private FilterService() {
<b class="fc">&nbsp;        super(new FilterDAO(), new FilterType(), new Indexer&lt;&gt;(Filter.class), new Searcher(Filter.class));</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Return singleton variable of type FilterService.
&nbsp;     *
&nbsp;     * @return unique instance of FilterService
&nbsp;     */
&nbsp;    public static FilterService getInstance() {
<b class="fc">&nbsp;        FilterService localReference = instance;</b>
<b class="fc">&nbsp;        if (Objects.isNull(localReference)) {</b>
<b class="fc">&nbsp;            synchronized (FilterService.class) {</b>
<b class="fc">&nbsp;                localReference = instance;</b>
<b class="fc">&nbsp;                if (Objects.isNull(localReference)) {</b>
<b class="fc">&nbsp;                    localReference = new FilterService();</b>
<b class="fc">&nbsp;                    instance = localReference;</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
&nbsp;        }
<b class="fc">&nbsp;        return localReference;</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Long countDatabaseRows() throws DAOException {
<b class="fc">&nbsp;        return countDatabaseRows(&quot;SELECT COUNT(*) FROM Filter&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Long countNotIndexedDatabaseRows() throws DAOException {
<b class="nc">&nbsp;        return countDatabaseRows(&quot;SELECT COUNT(*) FROM Filter WHERE indexAction = &#39;INDEX&#39; OR indexAction IS NULL&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public Long countResults(Map filters) throws DataException {
<b class="nc">&nbsp;        return countDocuments(QueryBuilders.matchAllQuery());</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;Filter&gt; getAllNotIndexed() {
<b class="nc">&nbsp;        return getByQuery(&quot;FROM Filter WHERE indexAction = &#39;INDEX&#39; OR indexAction IS NULL&quot;);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public List&lt;Filter&gt; loadData(int first, int pageSize, String sortField, SortOrder sortOrder, Map filters) {
<b class="nc">&nbsp;        return new ArrayList&lt;&gt;();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Find filters with exact value.
&nbsp;     *
&nbsp;     * @param value
&nbsp;     *            of the searched filter
&nbsp;     * @param contains
&nbsp;     *            of the searched filter
&nbsp;     * @return list of JSON objects with properties
&nbsp;     */
&nbsp;    List&lt;Map&lt;String, Object&gt;&gt; findByValue(String value, boolean contains) throws DataException {
<b class="fc">&nbsp;        QueryBuilder query = createSimpleQuery(FilterTypeField.VALUE.getKey(), value, contains, Operator.AND);</b>
<b class="fc">&nbsp;        return findDocuments(query);</b>
&nbsp;    }
&nbsp;
&nbsp;    @Override
&nbsp;    public FilterDTO convertJSONObjectToDTO(Map&lt;String, Object&gt; jsonObject, boolean related) throws DataException {
<b class="nc">&nbsp;        FilterDTO filterDTO = new FilterDTO();</b>
<b class="nc">&nbsp;        filterDTO.setId(getIdFromJSONObject(jsonObject));</b>
<b class="nc">&nbsp;        filterDTO.setValue(FilterTypeField.VALUE.getStringValue(jsonObject));</b>
<b class="nc">&nbsp;        return filterDTO;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This method builds a criteria depending on a filter string and some other
&nbsp;     * parameters passed on along the initial criteria. The filter is parsed and
&nbsp;     * depending on which data structures are used for applying filtering
&nbsp;     * restrictions conjunctions are formed and collect the restrictions and
&nbsp;     * then will be applied on the corresponding criteria. A criteria is only
&nbsp;     * added if needed for the presence of filters applying to it. 
&nbsp;     * 
&nbsp;     * &lt;p&gt;Filters are enclosed in double quotes and separated via a space. 
&nbsp;     * Each filter can be a disjunction of conditions separated by a &quot;|&quot;. 
&nbsp;     * Conditions can be negated by adding the prefix &quot;-&quot;.&lt;/p&gt;
&nbsp;     * 
&nbsp;     * &lt;p&gt;Some examples are: the default filter &quot;word&quot;, which filters task or 
&nbsp;     * processes by their title; a filter &quot;stepinwork:Scanning&quot;, which filters 
&nbsp;     * processes or tasks by the task state &quot;Scanning&quot; which are also currently in 
&nbsp;     * progress. The negation thereof would be &quot;-stepinwork:Scanning&quot;. A disjunction 
&nbsp;     * of conditions would be &quot;stepinwork:Scanning | stepinwork:QC&quot;.&lt;/p&gt;
&nbsp;     *
&nbsp;     * @param filters
&nbsp;     *            as String
&nbsp;     * @param objectType
&nbsp;     *            as ObjectType - &quot;PROCESS&quot;, &quot;TEMPLATE&quot; or &quot;TASK&quot;
&nbsp;     * @param onlyOpenTasks
&nbsp;     *            as Boolean
&nbsp;     * @param onlyUserAssignedTasks
&nbsp;     *            as Boolean
&nbsp;     * @return query as {@link BoolQueryBuilder}
&nbsp;     */
&nbsp;    public BoolQueryBuilder queryBuilder(String filters, ObjectType objectType, Boolean onlyOpenTasks,
&nbsp;            Boolean onlyUserAssignedTasks) throws DataException {
&nbsp;
<b class="fc">&nbsp;        filters = replaceLegacyFilters(filters);</b>
<b class="fc">&nbsp;        BoolQueryBuilder query = new BoolQueryBuilder();</b>
&nbsp;
&nbsp;        // this is needed if we filter task
<b class="fc">&nbsp;        if (objectType == ObjectType.TASK) {</b>
<b class="fc">&nbsp;            query = buildTaskQuery(onlyOpenTasks, onlyUserAssignedTasks);</b>
&nbsp;        }
&nbsp;
<b class="fc">&nbsp;        for (String filter : splitFilters(filters)) {</b>
<b class="fc">&nbsp;            BoolQueryBuilder bool = new BoolQueryBuilder();</b>
<b class="fc">&nbsp;            for (String condition : splitConditions(filter)) {</b>
<b class="fc">&nbsp;                boolean negated = condition.startsWith(&quot;-&quot;);</b>
<b class="fc">&nbsp;                if (negated) {</b>
<b class="fc">&nbsp;                    bool.should(new BoolQueryBuilder().mustNot(</b>
<b class="fc">&nbsp;                        buildQueryFromCondition(condition.substring(1), objectType))</b>
&nbsp;                    );
&nbsp;                } else {
<b class="fc">&nbsp;                    bool.should(buildQueryFromCondition(condition, objectType));</b>
&nbsp;                }
<b class="fc">&nbsp;            }</b>
<b class="fc">&nbsp;            query.must(bool);</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return query;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Splits a filter into multiple alternative conditions.
&nbsp;     * 
&nbsp;     * @param filter the filter string (that was enclosed in double quotes)
&nbsp;     * @return a list of conditions after splitting the filter at the &quot;|&quot; character
&nbsp;     */
&nbsp;    private List&lt;String&gt; splitConditions(String filter) {
<b class="fc">&nbsp;        return CONDITION_PATTERN.matcher(filter).results()</b>
<b class="fc">&nbsp;            .flatMap(mr -&gt; IntStream.rangeClosed(1, mr.groupCount()).mapToObj(mr::group))</b>
<b class="fc">&nbsp;            .filter(Objects::nonNull)</b>
<b class="fc">&nbsp;            .map(String::trim)</b>
<b class="fc">&nbsp;            .filter(Predicate.not(String::isEmpty))</b>
<b class="fc">&nbsp;            .collect(Collectors.toList());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Builds a ElasticSearch query from a single condition.
&nbsp;     * 
&nbsp;     * @param condition the condition (e.g. a single word, or a pair of &quot;property:value&quot;)
&nbsp;     * @param objectType the object type that is being filtered (either task or process)
&nbsp;     * @return a elastic search query builder object representing the condition
&nbsp;     */
&nbsp;    private QueryBuilder buildQueryFromCondition(String condition, ObjectType objectType) throws DataException {
<b class="fc">&nbsp;        if (evaluateFilterString(condition, FilterString.TASK, null)) {</b>
<b class="fc">&nbsp;            return createHistoricFilter(condition);</b>
<b class="fc">&nbsp;        } else if (evaluateFilterString(condition, FilterString.TASKINWORK, null)) {</b>
<b class="fc">&nbsp;            return createTaskFilters(condition, FilterString.TASKINWORK, TaskStatus.INWORK, false, objectType);</b>
<b class="fc">&nbsp;        } else if (evaluateFilterString(condition, FilterString.TASKLOCKED, null)) {</b>
<b class="fc">&nbsp;            return createTaskFilters(condition, FilterString.TASKLOCKED, TaskStatus.LOCKED, false, objectType);</b>
<b class="fc">&nbsp;        } else if (evaluateFilterString(condition, FilterString.TASKOPEN, null)) {</b>
<b class="fc">&nbsp;            return createTaskFilters(condition, FilterString.TASKOPEN, TaskStatus.OPEN, false, objectType);</b>
<b class="fc">&nbsp;        } else if (evaluateFilterString(condition, FilterString.TASKDONE, null)) {</b>
<b class="fc">&nbsp;            return createTaskFilters(condition, FilterString.TASKDONE, TaskStatus.DONE, false, objectType);</b>
<b class="fc">&nbsp;        } else if (evaluateFilterString(condition, FilterString.TASKDONETITLE, null)) {</b>
<b class="nc">&nbsp;            String taskTitle = getFilterValueFromFilterString(condition, FilterString.TASKDONETITLE);</b>
<b class="nc">&nbsp;            return filterTaskTitle(taskTitle, TaskStatus.DONE, false, objectType);</b>
<b class="fc">&nbsp;        } else if (evaluateFilterString(condition, FilterString.TASKDONEUSER, null)</b>
<b class="nc">&nbsp;                &amp;&amp; ConfigCore.getBooleanParameterOrDefaultValue(ParameterCore.WITH_USER_STEP_DONE_SEARCH)) {</b>
<b class="nc">&nbsp;            return filterTaskDoneUser(condition, objectType);</b>
<b class="fc">&nbsp;        } else if (evaluateFilterString(condition, FilterString.TASKAUTOMATIC, null)) {</b>
<b class="nc">&nbsp;            return filterAutomaticTasks(condition, objectType);</b>
<b class="fc">&nbsp;        } else if (evaluateFilterString(condition, FilterString.PROJECT, null)) {</b>
<b class="fc">&nbsp;            return filterProject(condition, false, objectType);</b>
<b class="fc">&nbsp;        } else if (evaluateFilterString(condition, FilterString.ID, null)) {</b>
<b class="fc">&nbsp;            return createProcessIdFilter(condition, objectType);</b>
<b class="fc">&nbsp;        } else if (evaluateFilterString(condition, FilterString.PARENTPROCESSID, null)) {</b>
<b class="nc">&nbsp;            return createParentProcessIdFilter(condition, objectType);</b>
<b class="fc">&nbsp;        } else if (evaluateFilterString(condition, FilterString.PROPERTY, null)) {</b>
<b class="nc">&nbsp;            return createProcessPropertyFilter(condition, objectType);</b>
<b class="fc">&nbsp;        } else if (evaluateFilterString(condition, FilterString.PROCESS, null)) {</b>
<b class="fc">&nbsp;            return createProcessTitleFilter(condition, objectType);</b>
<b class="fc">&nbsp;        } else if (evaluateFilterString(condition, FilterString.BATCH, null)) {</b>
<b class="fc">&nbsp;            return createBatchIdFilter(condition, objectType, true);</b>
&nbsp;        } else {
&nbsp;            /* standard-search parameter */
<b class="fc">&nbsp;            return createDefaultQuery(condition, false, objectType);</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    private String replaceLegacyFilters(String filter) {
<b class="fc">&nbsp;        filter.replace(&quot;processproperty&quot;,&quot;property&quot;);</b>
<b class="fc">&nbsp;        filter.replace(&quot;workpiece&quot;,&quot;property&quot;);</b>
<b class="fc">&nbsp;        filter.replace(&quot;template&quot;,&quot;property&quot;);</b>
<b class="fc">&nbsp;        return filter;</b>
&nbsp;    }
&nbsp;
&nbsp;    private BoolQueryBuilder buildTaskQuery(Boolean onlyOpenTasks, Boolean onlyUserAssignedTasks) {
<b class="fc">&nbsp;        return limitToUserAssignedTasks(onlyOpenTasks, onlyUserAssignedTasks);</b>
&nbsp;    }
&nbsp;
&nbsp;    Set&lt;Integer&gt; collectIds(List&lt;? extends BaseDTO&gt; dtos) {
<b class="fc">&nbsp;        Set&lt;Integer&gt; ids = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        for (BaseDTO processDTO : dtos) {</b>
<b class="fc">&nbsp;            ids.add(processDTO.getId());</b>
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return ids;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get value for find objects in ElasticSearch.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            as String eg. in form &#39;stepdone:1&#39;
&nbsp;     * @param filterString
&nbsp;     *            as FilterString eg. &#39;stepdone:&#39;
&nbsp;     * @return value for find object &#39;1&#39;
&nbsp;     */
&nbsp;    private String getFilterValueFromFilterString(String filter, FilterString filterString) {
<b class="fc">&nbsp;        String filterEnglish = filterString.getFilterEnglish();</b>
<b class="fc">&nbsp;        String filterGerman = filterString.getFilterGerman();</b>
<b class="fc">&nbsp;        if (filter.contains(filterEnglish)) {</b>
<b class="fc">&nbsp;            return prepareStrings(filter, filterEnglish).get(0);</b>
<b class="nc">&nbsp;        } else if (filter.contains(filterGerman)) {</b>
<b class="nc">&nbsp;            return prepareStrings(filter, filterGerman).get(0);</b>
&nbsp;        }
<b class="nc">&nbsp;        return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Get list of values for find objects in ElasticSearch.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            as String eg. in form &#39;stepdone:1 2 3&#39;
&nbsp;     * @param filterString
&nbsp;     *            as FilterString e.g. &#39;stepdone:&#39;
&nbsp;     * @return list of values for find objects e.g. &#39;1&#39; &#39;2&#39; and so on
&nbsp;     */
&nbsp;    private List&lt;String&gt; getFilterValuesFromFilterString(String filter, FilterString filterString) {
<b class="fc">&nbsp;        String filterEnglish = filterString.getFilterEnglish();</b>
<b class="fc">&nbsp;        String filterGerman = filterString.getFilterGerman();</b>
<b class="fc">&nbsp;        List&lt;String&gt; filterValues = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        if (filter.contains(filterEnglish)) {</b>
<b class="fc">&nbsp;            filterValues = prepareStrings(filter, filterEnglish);</b>
<b class="nc">&nbsp;        } else if (filter.contains(filterGerman)) {</b>
<b class="nc">&nbsp;            filterValues = prepareStrings(filter, filterGerman);</b>
&nbsp;        }
<b class="fc">&nbsp;        return filterValues;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prepare list of values for given filter. Regexp checks if it contains
&nbsp;     * only numbers and white spaces. In that case it treats it as list of ids.
&nbsp;     * If value contains words and white spaces or single word it treats it as
&nbsp;     * text search.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            full filter String
&nbsp;     * @param filterName
&nbsp;     *            String which contains only name of filter e.g. &#39;stepdone:&#39;
&nbsp;     * @return list of values, in case if string this list has size one
&nbsp;     */
&nbsp;    private List&lt;String&gt; prepareStrings(String filter, String filterName) {
<b class="fc">&nbsp;        List&lt;String&gt; filterValues = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        String filterValue = filter.substring(filter.indexOf(filterName));</b>
<b class="fc">&nbsp;        filterValue = filterValue.substring(filterName.lastIndexOf(&#39;:&#39;) + 1);</b>
<b class="fc">&nbsp;        if (filterValue.matches(&quot;^[\\s\\d]+$&quot;)) {</b>
<b class="fc">&nbsp;            filterValues.addAll(Arrays.asList(filterValue.split(&quot;\\s+&quot;)));</b>
&nbsp;        } else {
<b class="fc">&nbsp;            filterValues.add(filterValue);</b>
&nbsp;        }
<b class="fc">&nbsp;        return filterValues;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Filters for properties are special type. They can contain two times :
&nbsp;     * e.g. &#39;processproperty:title:value&#39;.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            full filter String
&nbsp;     * @param filterString
&nbsp;     *            contains only name of filter e.g. &#39;processproperty:&#39; as String
&nbsp;     * @return list of values in format property title and property value or
&nbsp;     *         only property value
&nbsp;     */
&nbsp;    private List&lt;String&gt; getFilterValueFromFilterStringForProperty(String filter, FilterString filterString) {
<b class="nc">&nbsp;        List&lt;String&gt; titleValue = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        String filterEnglish = filterString.getFilterEnglish();</b>
<b class="nc">&nbsp;        String filterGerman = filterString.getFilterGerman();</b>
<b class="nc">&nbsp;        if (filter.contains(filterEnglish)) {</b>
<b class="nc">&nbsp;            titleValue = prepareStringsForProperty(filter, filterEnglish);</b>
<b class="nc">&nbsp;        } else if (filter.contains(filterGerman)) {</b>
<b class="nc">&nbsp;            titleValue = prepareStringsForProperty(filter, filterGerman);</b>
&nbsp;        }
<b class="nc">&nbsp;        return titleValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prepare list of values in format property title and property value or
&nbsp;     * only property value.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            full filter String
&nbsp;     * @param filterName
&nbsp;     *            contains only name of filter e.g. &#39;processproperty:&#39; as String
&nbsp;     * @return list of values in format property title and property value or
&nbsp;     *         only property value.
&nbsp;     */
&nbsp;    private List&lt;String&gt; prepareStringsForProperty(String filter, String filterName) {
<b class="nc">&nbsp;        List&lt;String&gt; titleValue = new ArrayList&lt;&gt;();</b>
<b class="nc">&nbsp;        String filterValue = filter.replace(filterName, &quot;&quot;);</b>
<b class="nc">&nbsp;        if (filterValue.contains(&quot;:&quot;)) {</b>
<b class="nc">&nbsp;            titleValue.add(filterValue.substring(0, filterValue.lastIndexOf(&#39;:&#39;)));</b>
<b class="nc">&nbsp;            titleValue.add(filterValue.substring(filterValue.lastIndexOf(&#39;:&#39;) + 1));</b>
&nbsp;        } else {
<b class="nc">&nbsp;            titleValue.add(filterValue);</b>
&nbsp;        }
<b class="nc">&nbsp;        return titleValue;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Prepare list of single filters from given one long filter. Filters are
&nbsp;     * delimited by &quot;.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            as String
&nbsp;     * @return list of single filters
&nbsp;     */
&nbsp;    private List&lt;String&gt; splitFilters(String filter) {
<b class="fc">&nbsp;        List&lt;String&gt; filters = new ArrayList&lt;&gt;();</b>
<b class="fc">&nbsp;        String delimiter = &quot;\&quot;&quot;;</b>
<b class="fc">&nbsp;        StringTokenizer tokenizer = new StringTokenizer(filter, delimiter, true);</b>
<b class="fc">&nbsp;        while (tokenizer.hasMoreTokens()) {</b>
<b class="fc">&nbsp;            String token = tokenizer.nextToken();</b>
<b class="fc">&nbsp;            if (!token.equals(delimiter) &amp;&amp; !token.equals(&quot; &quot;)) {</b>
<b class="fc">&nbsp;                filters.add(token);</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return filters;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Evaluate FilterString objects in both possible languages.
&nbsp;     *
&nbsp;     * @param stringFilterString
&nbsp;     *            full filter String
&nbsp;     * @param filterString
&nbsp;     *            as FilterString object
&nbsp;     * @param prefix
&nbsp;     *            possible prefix is &#39;-&#39;, if prefix not null it means that we
&nbsp;     *            are filtering for negated value
&nbsp;     * @return true or false
&nbsp;     */
&nbsp;    private boolean evaluateFilterString(String stringFilterString, FilterString filterString, String prefix) {
<b class="fc">&nbsp;        String lowerCaseFilterString = stringFilterString.toLowerCase();</b>
<b class="fc">&nbsp;        if (Objects.nonNull(prefix)) {</b>
<b class="nc">&nbsp;            return lowerCaseFilterString.startsWith(prefix + filterString.getFilterEnglish())</b>
<b class="nc">&nbsp;                    || lowerCaseFilterString.startsWith(prefix + filterString.getFilterGerman());</b>
&nbsp;        }
<b class="fc">&nbsp;        return lowerCaseFilterString.startsWith(filterString.getFilterEnglish())</b>
<b class="fc">&nbsp;                || lowerCaseFilterString.startsWith(filterString.getFilterGerman());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Show only open tasks or those in use by current user.
&nbsp;     *
&nbsp;     * @param onlyOpenTask
&nbsp;     *            filter only by open tasks - true/false
&nbsp;     * @param onlyUserAssignedTask
&nbsp;     *            filter only open tasks - true/false
&nbsp;     * @return query as {@link BoolQueryBuilder}
&nbsp;     */
&nbsp;    private BoolQueryBuilder limitToUserAssignedTasks(Boolean onlyOpenTask, Boolean onlyUserAssignedTask) {
&nbsp;        // identify current user
<b class="fc">&nbsp;        User user = ServiceManager.getUserService().getCurrentUser();</b>
&nbsp;
&nbsp;        // hits by user groups
<b class="fc">&nbsp;        BoolQueryBuilder taskQuery = new BoolQueryBuilder();</b>
&nbsp;
<b class="fc">&nbsp;        if (onlyOpenTask) {</b>
<b class="fc">&nbsp;            taskQuery.must(createSimpleQuery(TaskTypeField.PROCESSING_STATUS.getKey(), 1, true));</b>
<b class="fc">&nbsp;        } else if (onlyUserAssignedTask) {</b>
<b class="nc">&nbsp;            taskQuery.must(createSimpleQuery(TaskTypeField.PROCESSING_STATUS.getKey(), 1, true));</b>
<b class="nc">&nbsp;            taskQuery.must(createSimpleQuery(TaskTypeField.PROCESSING_USER_ID.getKey(), user.getId(), true));</b>
&nbsp;        } else {
<b class="fc">&nbsp;            BoolQueryBuilder processingStatus = new BoolQueryBuilder();</b>
<b class="fc">&nbsp;            processingStatus.should(createSimpleQuery(TaskTypeField.PROCESSING_STATUS.getKey(), 1, true));</b>
<b class="fc">&nbsp;            processingStatus.should(createSimpleQuery(TaskTypeField.PROCESSING_STATUS.getKey(), 2, true));</b>
<b class="fc">&nbsp;            taskQuery.must(processingStatus);</b>
&nbsp;        }
&nbsp;
&nbsp;        // ignore template tasks
<b class="fc">&nbsp;        taskQuery.mustNot(createSimpleQuery(TaskTypeField.PROCESS_ID.getKey(),(Integer) null, true));</b>
&nbsp;
&nbsp;        // only tasks assigned to the user groups the current user is member of
<b class="fc">&nbsp;        List&lt;Role&gt; userRoles = user.getRoles();</b>
<b class="fc">&nbsp;        taskQuery.must(createSetQueryForBeans(TaskTypeField.ROLES + &quot;.id&quot;, userRoles, true));</b>
&nbsp;
<b class="fc">&nbsp;        return taskQuery;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * //TODO: why it is called historic filter? Create historic filer.
&nbsp;     *
&nbsp;     * @param filterPart
&nbsp;     *            String
&nbsp;     * @return query as {@link QueryBuilder}
&nbsp;     */
&nbsp;    private QueryBuilder createHistoricFilter(String filterPart) {
&nbsp;        /* filtering by a certain minimal status */
<b class="fc">&nbsp;        int taskOrdering = 1;</b>
<b class="fc">&nbsp;        BoolQueryBuilder historicFilter = new BoolQueryBuilder();</b>
<b class="fc">&nbsp;        String taskTitle = getFilterValueFromFilterString(filterPart, FilterString.TASK);</b>
<b class="fc">&nbsp;        if (Objects.nonNull(taskTitle)) {</b>
&nbsp;            try {
<b class="fc">&nbsp;                taskOrdering = Integer.parseInt(taskTitle);</b>
<b class="fc">&nbsp;            } catch (NumberFormatException e) {</b>
<b class="fc">&nbsp;                taskTitle = filterPart.substring(filterPart.indexOf(&#39;:&#39;) + 1);</b>
<b class="fc">&nbsp;                historicFilter.must(createSimpleCompareQuery(TaskTypeField.PROCESSING_STATUS.getKey(),</b>
<b class="fc">&nbsp;                    TaskStatus.OPEN.getValue(), SearchCondition.EQUAL_OR_BIGGER));</b>
<b class="fc">&nbsp;                if (taskTitle.startsWith(&quot;-&quot;)) {</b>
<b class="nc">&nbsp;                    taskTitle = taskTitle.substring(1);</b>
<b class="nc">&nbsp;                    historicFilter.mustNot(createSimpleWildcardQuery(TaskTypeField.TITLE.getKey(), taskTitle));</b>
&nbsp;                } else {
<b class="fc">&nbsp;                    historicFilter.must(createSimpleWildcardQuery(TaskTypeField.TITLE.getKey(), taskTitle));</b>
&nbsp;                }
<b class="nc">&nbsp;            }</b>
&nbsp;        }
<b class="fc">&nbsp;        historicFilter.must(createSimpleQuery(TaskTypeField.ORDERING.getKey(), taskOrdering, true));</b>
<b class="fc">&nbsp;        return historicFilter;</b>
&nbsp;    }
&nbsp;
&nbsp;    private QueryBuilder createParentProcessIdFilter(String filter, ObjectType objectType) {
<b class="nc">&nbsp;        if (objectType == ObjectType.PROCESS) {</b>
<b class="nc">&nbsp;            return createSetQuery(&quot;parent.id&quot;, filterValuesAsIntegers(filter, FilterString.PARENTPROCESSID), true);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new BoolQueryBuilder();</b>
&nbsp;    }
&nbsp;
&nbsp;    private QueryBuilder createProcessIdFilter(String filter, ObjectType objectType) {
<b class="fc">&nbsp;        if (objectType == ObjectType.PROCESS) {</b>
<b class="fc">&nbsp;            return createSetQuery(&quot;_id&quot;, filterValuesAsStrings(filter, FilterString.ID), true);</b>
<b class="fc">&nbsp;        } else if (objectType == ObjectType.TASK) {</b>
<b class="fc">&nbsp;            return createSetQuery(TaskTypeField.PROCESS_ID.getKey(), filterValuesAsIntegers(filter, FilterString.ID),</b>
&nbsp;                true);
&nbsp;        }
<b class="nc">&nbsp;        return new BoolQueryBuilder();</b>
&nbsp;    }
&nbsp;
&nbsp;    private QueryBuilder createProcessPropertyFilter(String filter, ObjectType objectType) throws DataException {
<b class="nc">&nbsp;        BoolQueryBuilder propertyQuery = new BoolQueryBuilder();</b>
<b class="nc">&nbsp;        Set&lt;String&gt; strings = filterValuesAsStrings(filter, FilterString.PROPERTY);</b>
<b class="nc">&nbsp;        for (String string : strings) {</b>
<b class="nc">&nbsp;            String[] split = string.split(&quot;:&quot;);</b>
<b class="nc">&nbsp;            if (split.length &gt; 1) {</b>
<b class="nc">&nbsp;                propertyQuery.should(ServiceManager.getProcessService().createPropertyQuery(split[0], split[1]));</b>
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        if (objectType == ObjectType.PROCESS) {</b>
<b class="nc">&nbsp;            return propertyQuery;</b>
<b class="nc">&nbsp;        } else if (objectType == ObjectType.TASK) {</b>
<b class="nc">&nbsp;            return getQueryAccordingToObjectTypeAndSearchInObject(ObjectType.TASK, ObjectType.PROCESS, propertyQuery);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new BoolQueryBuilder();</b>
&nbsp;    }
&nbsp;
&nbsp;    private QueryBuilder createProcessTitleFilter(String filter, ObjectType objectType) {
<b class="fc">&nbsp;        String processTitle = getFilterValueFromFilterString(filter, FilterString.PROCESS);</b>
<b class="fc">&nbsp;        if (objectType == ObjectType.PROCESS) {</b>
<b class="fc">&nbsp;            return ServiceManager.getProcessService().getWildcardQueryTitle(processTitle);</b>
<b class="fc">&nbsp;        } else if (objectType == ObjectType.TASK) {</b>
<b class="fc">&nbsp;            return createSimpleQuery(TaskTypeField.PROCESS_TITLE.getKey(), processTitle, true, Operator.AND);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new BoolQueryBuilder();</b>
&nbsp;    }
&nbsp;
&nbsp;    private QueryBuilder createBatchIdFilter(String filter, ObjectType objectType, boolean negate) throws DataException {
<b class="fc">&nbsp;        if (objectType == ObjectType.PROCESS) {</b>
<b class="fc">&nbsp;            return createSetQuery(&quot;batches.id&quot;, filterValuesAsIntegers(filter, FilterString.BATCH), negate);</b>
<b class="nc">&nbsp;        } else if (objectType == ObjectType.TASK) {</b>
<b class="nc">&nbsp;            List&lt;ProcessDTO&gt; processDTOS = ServiceManager.getProcessService().findByQuery(</b>
<b class="nc">&nbsp;                createSetQuery(&quot;batches.id&quot;, filterValuesAsIntegers(filter, FilterString.BATCH), negate), true);</b>
<b class="nc">&nbsp;            return createSetQuery(TaskTypeField.PROCESS_ID.getKey(), collectIds(processDTOS), negate);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new BoolQueryBuilder();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create task filters.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            String
&nbsp;     * @param filterString
&nbsp;     *            as {@link FilterString}
&nbsp;     * @param taskStatus
&nbsp;     *            {@link TaskStatus} of searched step
&nbsp;     * @param negate
&nbsp;     *            true or false, if true create simple queries with contains
&nbsp;     *            false
&nbsp;     * @param objectType
&nbsp;     *            as {@link ObjectType}
&nbsp;     * @return query as {@link QueryBuilder}
&nbsp;     */
&nbsp;    private QueryBuilder createTaskFilters(String filter, FilterString filterString, TaskStatus taskStatus,
&nbsp;            boolean negate, ObjectType objectType) {
&nbsp;        /*
&nbsp;         * extracting the substring into parameter (filter parameters e.g. 5,
&nbsp;         * -5, 5-10, 5- or &quot;Qualitätssicherung&quot;)
&nbsp;         */
<b class="fc">&nbsp;        String parameters = getFilterValueFromFilterString(filter, filterString);</b>
&nbsp;
&nbsp;        /*
&nbsp;         * Analyzing the parameters and what user intended (5-&gt;exact, -5 -&gt;max,
&nbsp;         * 5-10 -&gt;range, 5- -&gt;min., Qualitätssicherung -&gt;name) handling the
&nbsp;         * filter according to the parameters
&nbsp;         */
<b class="fc">&nbsp;        switch (getTaskFilter(parameters)) {</b>
&nbsp;            case EXACT:
&nbsp;                try {
<b class="fc">&nbsp;                    return filterTaskExact(parameters, taskStatus, negate, objectType);</b>
<b class="nc">&nbsp;                } catch (NullPointerException e) {</b>
<b class="nc">&nbsp;                    logger.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;                    logger.error(&quot;stepdone is preset, don&#39;t use &#39;step&#39; filters&quot;);</b>
<b class="nc">&nbsp;                } catch (DataException | RuntimeException e) {</b>
<b class="nc">&nbsp;                    logger.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;                    logError(filter);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case MAX:
&nbsp;                try {
<b class="nc">&nbsp;                    return filterTaskMax(parameters, taskStatus, negate, objectType);</b>
<b class="nc">&nbsp;                } catch (NullPointerException e) {</b>
<b class="nc">&nbsp;                    logger.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;                    logger.error(&quot;stepdone is preset, don&#39;t use &#39;step&#39; filters&quot;);</b>
<b class="nc">&nbsp;                } catch (DataException | RuntimeException e) {</b>
<b class="nc">&nbsp;                    logger.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;                    logError(filter);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case MIN:
&nbsp;                try {
<b class="nc">&nbsp;                    return filterTaskMin(parameters, taskStatus, negate, objectType);</b>
<b class="nc">&nbsp;                } catch (NullPointerException e) {</b>
<b class="nc">&nbsp;                    logger.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;                    logger.error(&quot;stepdone is preset, don&#39;t use &#39;step&#39; filters&quot;);</b>
<b class="nc">&nbsp;                } catch (DataException | RuntimeException e) {</b>
<b class="nc">&nbsp;                    logger.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;                    logError(filter);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case NAME:
&nbsp;                /* filter for a specific done step by it&#39;s name (title) */
&nbsp;                try {
<b class="fc">&nbsp;                    return filterTaskTitle(parameters, taskStatus, negate, objectType);</b>
<b class="nc">&nbsp;                } catch (NullPointerException e) {</b>
<b class="nc">&nbsp;                    logger.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;                    logger.error(&quot;stepdone is preset, don&#39;t use &#39;step&#39; filters&quot;);</b>
<b class="nc">&nbsp;                } catch (DataException | RuntimeException e) {</b>
<b class="nc">&nbsp;                    logger.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;                    logError(filter);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case RANGE:
&nbsp;                try {
<b class="nc">&nbsp;                    return filterTaskRange(parameters, taskStatus, negate, objectType);</b>
<b class="nc">&nbsp;                } catch (NullPointerException e) {</b>
<b class="nc">&nbsp;                    logger.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;                    logger.error(&quot;stepdone is preset, don&#39;t use &#39;step&#39; filters&quot;);</b>
<b class="nc">&nbsp;                } catch (NumberFormatException e) {</b>
<b class="nc">&nbsp;                    logger.debug(e.getMessage(), e);</b>
&nbsp;                    try {
<b class="nc">&nbsp;                        return filterTaskTitle(parameters, taskStatus, negate, objectType);</b>
<b class="nc">&nbsp;                    } catch (NullPointerException e1) {</b>
<b class="nc">&nbsp;                        logger.error(e1.getMessage(), e1);</b>
<b class="nc">&nbsp;                        logger.error(&quot;stepdone is preset, don&#39;t use &#39;step&#39; filters&quot;);</b>
<b class="nc">&nbsp;                    } catch (DataException | RuntimeException e1) {</b>
<b class="nc">&nbsp;                        logger.error(e1.getMessage(), e1);</b>
<b class="nc">&nbsp;                        logError(filter);</b>
<b class="nc">&nbsp;                    }</b>
<b class="nc">&nbsp;                } catch (DataException | RuntimeException e) {</b>
<b class="nc">&nbsp;                    logger.error(e.getMessage(), e);</b>
<b class="nc">&nbsp;                    logError(filter);</b>
<b class="nc">&nbsp;                }</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            case UNKNOWN:
<b class="nc">&nbsp;                logger.info(&quot;Filter &#39;{}&#39; is not known!&quot;, filter);</b>
<b class="nc">&nbsp;                break;</b>
&nbsp;            default:
&nbsp;                break;
&nbsp;        }
<b class="nc">&nbsp;        return new BoolQueryBuilder();</b>
&nbsp;    }
&nbsp;
&nbsp;    private void logError(String filter) {
<b class="nc">&nbsp;        logger.error(&quot;filter part &#39;{}&#39; in &#39;{}&#39; caused an error&quot;, filter.substring(filter.indexOf(&#39;:&#39;) + 1), filter);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This function analyzes the parameters on a task filter and returns a
&nbsp;     * TaskFilter enum to direct further processing it reduces the necessity to
&nbsp;     * apply some filter keywords.
&nbsp;     *
&nbsp;     * @param parameters
&nbsp;     *            String
&nbsp;     * @return TaskFilter
&nbsp;     */
&nbsp;    private static TaskFilter getTaskFilter(String parameters) {
&nbsp;
<b class="fc">&nbsp;        if (parameters.contains(&quot;-&quot;)) {</b>
<b class="nc">&nbsp;            String[] strArray = parameters.split(&quot;-&quot;);</b>
<b class="nc">&nbsp;            if (Arrays.stream(strArray).allMatch(StringUtils::isNumeric)) {</b>
<b class="nc">&nbsp;                if (strArray.length &gt;= 2) {</b>
<b class="nc">&nbsp;                    if (strArray[0].length() == 0) {</b>
<b class="nc">&nbsp;                        return TaskFilter.MAX;</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        return TaskFilter.RANGE;</b>
&nbsp;                    }
&nbsp;                } else {
<b class="nc">&nbsp;                    return TaskFilter.MIN;</b>
&nbsp;                }
&nbsp;            } else {
<b class="nc">&nbsp;                return TaskFilter.NAME;</b>
&nbsp;            }
<b class="fc">&nbsp;        } else if (!parameters.isEmpty() &amp;&amp; StringUtils.isNumeric(parameters)) {</b>
<b class="fc">&nbsp;            return TaskFilter.EXACT;</b>
&nbsp;        } else {
<b class="fc">&nbsp;            return TaskFilter.NAME;</b>
&nbsp;        }
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This enum represents the result of parsing the step&amp;lt;modifier&amp;gt;:
&nbsp;     * filter Restrictions.
&nbsp;     */
<b class="fc">&nbsp;    private enum TaskFilter {</b>
<b class="fc">&nbsp;        EXACT,</b>
<b class="fc">&nbsp;        RANGE,</b>
<b class="fc">&nbsp;        MIN,</b>
<b class="fc">&nbsp;        MAX,</b>
<b class="fc">&nbsp;        NAME,</b>
<b class="fc">&nbsp;        UNKNOWN</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Filter processes for done steps range.
&nbsp;     *
&nbsp;     * @param parameters
&nbsp;     *            String
&nbsp;     * @param taskStatus
&nbsp;     *            {@link TaskStatus} of searched step
&nbsp;     * @param negate
&nbsp;     *            true or false, if true create simple queries with contains
&nbsp;     *            false
&nbsp;     * @param objectType
&nbsp;     *            as {@link ObjectType}
&nbsp;     * @return query as {@link QueryBuilder}
&nbsp;     */
&nbsp;    private QueryBuilder filterTaskRange(String parameters, TaskStatus taskStatus, boolean negate,
&nbsp;            ObjectType objectType) throws DataException {
<b class="nc">&nbsp;        BoolQueryBuilder taskRange = new BoolQueryBuilder();</b>
<b class="nc">&nbsp;        if (!negate) {</b>
<b class="nc">&nbsp;            taskRange.must(createSimpleCompareQuery(TaskTypeField.ORDERING.getKey(), getTaskStart(parameters),</b>
&nbsp;                SearchCondition.EQUAL_OR_BIGGER));
<b class="nc">&nbsp;            taskRange.must(createSimpleCompareQuery(TaskTypeField.ORDERING.getKey(), getTaskEnd(parameters),</b>
&nbsp;                SearchCondition.EQUAL_OR_SMALLER));
<b class="nc">&nbsp;            taskRange.must(createSimpleCompareQuery(TaskTypeField.PROCESSING_STATUS.getKey(), taskStatus.getValue(),</b>
&nbsp;                SearchCondition.EQUAL));
&nbsp;        } else {
<b class="nc">&nbsp;            taskRange.mustNot(createSimpleCompareQuery(TaskTypeField.ORDERING.getKey(), getTaskStart(parameters),</b>
&nbsp;                SearchCondition.EQUAL_OR_BIGGER));
<b class="nc">&nbsp;            taskRange.mustNot(createSimpleCompareQuery(TaskTypeField.ORDERING.getKey(), getTaskEnd(parameters),</b>
&nbsp;                SearchCondition.EQUAL_OR_SMALLER));
<b class="nc">&nbsp;            taskRange.mustNot(createSimpleCompareQuery(TaskTypeField.PROCESSING_STATUS.getKey(), taskStatus.getValue(),</b>
&nbsp;                SearchCondition.EQUAL));
&nbsp;        }
<b class="nc">&nbsp;        return getQueryAccordingToObjectTypeAndSearchInObject(objectType, ObjectType.TASK, taskRange);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Filter processes for steps name with given status.
&nbsp;     *
&nbsp;     * @param taskStatus
&nbsp;     *            {@link TaskStatus} of searched step
&nbsp;     * @param parameters
&nbsp;     *            part of filter string to use
&nbsp;     * @param negate
&nbsp;     *            true or false, if true create simple queries with contains
&nbsp;     *            false
&nbsp;     * @param objectType
&nbsp;     *            as {@link ObjectType}
&nbsp;     * @return query as {@link QueryBuilder}
&nbsp;     */
&nbsp;    private QueryBuilder filterTaskTitle(String parameters, TaskStatus taskStatus, boolean negate,
&nbsp;            ObjectType objectType) throws DataException {
<b class="fc">&nbsp;        BoolQueryBuilder taskTitle = new BoolQueryBuilder();</b>
<b class="fc">&nbsp;        taskTitle.must(createSimpleQuery(TaskTypeField.TITLE.getKey() + &quot;.keyword&quot;, parameters, !negate));</b>
<b class="fc">&nbsp;        taskTitle.must(createSimpleQuery(TaskTypeField.PROCESSING_STATUS.getKey(), taskStatus.getValue(), !negate));</b>
<b class="fc">&nbsp;        return getQueryAccordingToObjectTypeAndSearchInObject(objectType, ObjectType.TASK, taskTitle);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Filter processes for done steps min.
&nbsp;     *
&nbsp;     * @param parameters
&nbsp;     *            part of filter string to use
&nbsp;     * @param taskStatus
&nbsp;     *            {@link TaskStatus} of searched step
&nbsp;     * @param negate
&nbsp;     *            true or false, if true create simple queries with contains
&nbsp;     *            false
&nbsp;     * @param objectType
&nbsp;     *            as {@link ObjectType}
&nbsp;     * @return query as {@link QueryBuilder}
&nbsp;     */
&nbsp;    private QueryBuilder filterTaskMin(String parameters, TaskStatus taskStatus, boolean negate, ObjectType objectType)
&nbsp;            throws DataException {
<b class="nc">&nbsp;        BoolQueryBuilder taskMin = new BoolQueryBuilder();</b>
<b class="nc">&nbsp;        taskMin.must(createSimpleQuery(TaskTypeField.ORDERING.getKey(), getTaskStart(parameters), !negate));</b>
<b class="nc">&nbsp;        taskMin.must(createSimpleQuery(TaskTypeField.PROCESSING_STATUS.getKey(), taskStatus.getValue(), !negate));</b>
<b class="nc">&nbsp;        return getQueryAccordingToObjectTypeAndSearchInObject(objectType, ObjectType.TASK, taskMin);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Filter processes for done tasks max.
&nbsp;     *
&nbsp;     * @param parameters
&nbsp;     *            part of filter string to use
&nbsp;     * @param taskStatus
&nbsp;     *            {@link TaskStatus} of searched task
&nbsp;     * @param negate
&nbsp;     *            true or false, if true create simple queries with contains
&nbsp;     *            false
&nbsp;     * @param objectType
&nbsp;     *            as {@link ObjectType}
&nbsp;     * @return query as {@link QueryBuilder}
&nbsp;     */
&nbsp;    private QueryBuilder filterTaskMax(String parameters, TaskStatus taskStatus, boolean negate, ObjectType objectType)
&nbsp;            throws DataException {
<b class="nc">&nbsp;        BoolQueryBuilder taskMax = new BoolQueryBuilder();</b>
<b class="nc">&nbsp;        taskMax.must(createSimpleQuery(TaskTypeField.ORDERING.getKey(), getTaskEnd(parameters), !negate));</b>
<b class="nc">&nbsp;        taskMax.must(createSimpleQuery(TaskTypeField.PROCESSING_STATUS.getKey(), taskStatus.getValue(), !negate));</b>
<b class="nc">&nbsp;        return getQueryAccordingToObjectTypeAndSearchInObject(objectType, ObjectType.TASK, taskMax);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Filter processes for done tasks exact.
&nbsp;     *
&nbsp;     * @param parameters
&nbsp;     *            part of filter string to use
&nbsp;     * @param taskStatus
&nbsp;     *            {@link TaskStatus} of searched task
&nbsp;     * @param negate
&nbsp;     *            true or false, if true create simple queries with contains
&nbsp;     *            false
&nbsp;     * @param objectType
&nbsp;     *            as {@link ObjectType}
&nbsp;     * @return query as {@link QueryBuilder}
&nbsp;     */
&nbsp;    private QueryBuilder filterTaskExact(String parameters, TaskStatus taskStatus, boolean negate,
&nbsp;            ObjectType objectType) throws DataException {
<b class="fc">&nbsp;        BoolQueryBuilder taskExact = new BoolQueryBuilder();</b>
<b class="fc">&nbsp;        taskExact.must(createSimpleQuery(TaskTypeField.ORDERING.getKey(), getTaskStart(parameters), !negate));</b>
<b class="fc">&nbsp;        taskExact.must(createSimpleQuery(TaskTypeField.PROCESSING_STATUS.getKey(), taskStatus.getValue(), !negate));</b>
<b class="fc">&nbsp;        return getQueryAccordingToObjectTypeAndSearchInObject(objectType, ObjectType.TASK, taskExact);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Filter processes for done tasks by user.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            part of filter string to use - for user it looks it is login
&nbsp;     * @param objectType
&nbsp;     *            as {@link ObjectType}
&nbsp;     * @return query as {@link QueryBuilder}
&nbsp;     */
&nbsp;    private QueryBuilder filterTaskDoneUser(String filter, ObjectType objectType) {
&nbsp;        /*
&nbsp;         * filtering by a certain done step, which the current user finished
&nbsp;         */
&nbsp;        /*List&lt;TaskDTO&gt; taskDTOS = new ArrayList&lt;&gt;();
&nbsp;        String login = getFilterValueFromFilterString(filter, FilterString.TASKDONEUSER);
&nbsp;        try {
&nbsp;            Map&lt;String, Object&gt; user = ServiceManager.getUserService().findByLogin(login);
&nbsp;            UserDTO userDTO = ServiceManager.getUserService().convertJSONObjectToDTO(user, false);
&nbsp;            taskDTOS = userDTO.getProcessingTasks();
&nbsp;        } catch (DataException e) {
&nbsp;            logger.error(e.getMessage(), e);
&nbsp;        }
&nbsp;
&nbsp;        if (objectType == ObjectType.PROCESS) {
&nbsp;            return createSetQuery(&quot;tasks.id&quot;, collectIds(taskDTOS), true);
&nbsp;        } else if (objectType == ObjectType.TASK) {
&nbsp;            return createSetQuery(&quot;_id&quot;, collectIds(taskDTOS), true);
&nbsp;        }*/
<b class="nc">&nbsp;        return new BoolQueryBuilder();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Filter processes for tasks name with given status.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            as String
&nbsp;     * @param objectType
&nbsp;     *            as {@link ObjectType}
&nbsp;     * @return query as {@link QueryBuilder}
&nbsp;     */
&nbsp;    private QueryBuilder filterAutomaticTasks(String filter, ObjectType objectType) throws DataException {
<b class="nc">&nbsp;        BoolQueryBuilder typeAutomatic = new BoolQueryBuilder();</b>
<b class="nc">&nbsp;        String value = getFilterValueFromFilterString(filter, FilterString.TASKAUTOMATIC);</b>
<b class="nc">&nbsp;        if (Objects.nonNull(value)) {</b>
<b class="nc">&nbsp;            typeAutomatic.must(</b>
<b class="nc">&nbsp;                createSimpleQuery(TaskTypeField.TYPE_AUTOMATIC.getKey(), value.equalsIgnoreCase(&quot;true&quot;), true));</b>
&nbsp;        }
<b class="nc">&nbsp;        return getQueryAccordingToObjectTypeAndSearchInObject(objectType, ObjectType.TASK, typeAutomatic);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Filter processes by ids.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            part of filter string to use
&nbsp;     * @param filterString
&nbsp;     *            as FilterString
&nbsp;     * @return set of ids as Integers
&nbsp;     */
&nbsp;    private Set&lt;Integer&gt; filterValuesAsIntegers(String filter, FilterString filterString) {
<b class="fc">&nbsp;        Set&lt;Integer&gt; ids = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        List&lt;String&gt; stringIds = getFilterValuesFromFilterString(filter, filterString);</b>
<b class="fc">&nbsp;        for (String tempId : stringIds) {</b>
<b class="fc">&nbsp;            if (!tempId.isEmpty() &amp;&amp; StringUtils.isNumeric(tempId)) {</b>
<b class="fc">&nbsp;                Integer id = Integer.parseInt(tempId);</b>
<b class="fc">&nbsp;                ids.add(id);</b>
&nbsp;            }
<b class="fc">&nbsp;        }</b>
<b class="fc">&nbsp;        return ids;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Filter processes by Ids.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            part of filter string to use
&nbsp;     * @param filterString
&nbsp;     *            as FilterString
&nbsp;     * @return set of values as Strings
&nbsp;     */
&nbsp;    private Set&lt;String&gt; filterValuesAsStrings(String filter, FilterString filterString) {
<b class="fc">&nbsp;        Set&lt;String&gt; ids = new HashSet&lt;&gt;();</b>
<b class="fc">&nbsp;        List&lt;String&gt; stringIds = getFilterValuesFromFilterString(filter, filterString);</b>
<b class="fc">&nbsp;        if (!stringIds.isEmpty()) {</b>
<b class="fc">&nbsp;            ids.addAll(stringIds);</b>
&nbsp;        }
<b class="fc">&nbsp;        return ids;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Filter processes by project.
&nbsp;     *
&nbsp;     * @param filter
&nbsp;     *            part of filter string to use
&nbsp;     * @param negate
&nbsp;     *            true or false
&nbsp;     * @param objectType
&nbsp;     *            as {@link ObjectType}
&nbsp;     * @return query as {@link QueryBuilder}
&nbsp;     */
&nbsp;    private QueryBuilder filterProject(String filter, boolean negate, ObjectType objectType) throws DataException {
&nbsp;        // filter according to linked project
<b class="fc">&nbsp;        String projectTitle = getFilterValueFromFilterString(filter, FilterString.PROJECT);</b>
<b class="fc">&nbsp;        QueryBuilder projectQuery = ServiceManager.getProcessService().getQueryProjectTitle(projectTitle);</b>
<b class="fc">&nbsp;        return getQueryAccordingToObjectTypeAndSearchInObject(objectType, ObjectType.PROCESS, projectQuery);</b>
&nbsp;    }
&nbsp;
&nbsp;    private QueryBuilder createDefaultQuery(String filter, boolean negate, ObjectType objectType) throws DataException {
<b class="fc">&nbsp;        QueryBuilder titleQuery = ServiceManager.getProcessService().getWildcardQueryTitle(filter);</b>
<b class="fc">&nbsp;        QueryBuilder query = getQueryAccordingToObjectTypeAndSearchInObject(objectType, ObjectType.PROCESS, titleQuery);</b>
<b class="fc">&nbsp;        return negate ? new BoolQueryBuilder().mustNot(query) : query;</b>
&nbsp;    }
&nbsp;
&nbsp;    private QueryBuilder getQueryAccordingToObjectTypeAndSearchInObject(ObjectType objectType,
&nbsp;            ObjectType objectSearchIn, QueryBuilder query) throws DataException {
<b class="fc">&nbsp;        if (objectSearchIn == ObjectType.PROCESS) {</b>
<b class="fc">&nbsp;            return getQueryAccordingToObjectTypeAndSearchInProcess(objectType, query);</b>
<b class="fc">&nbsp;        } else if (objectSearchIn == ObjectType.TASK) {</b>
<b class="fc">&nbsp;            return getQueryAccordingToObjectTypeAndSearchInTask(objectType, query);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new BoolQueryBuilder();</b>
&nbsp;    }
&nbsp;
&nbsp;    private QueryBuilder getQueryAccordingToObjectTypeAndSearchInTask(ObjectType objectType, QueryBuilder query)
&nbsp;            throws DataException {
<b class="fc">&nbsp;        if (objectType == ObjectType.PROCESS) {</b>
<b class="fc">&nbsp;            List&lt;TaskDTO&gt; taskDTOS = ServiceManager.getTaskService().findByQuery(query, true);</b>
<b class="fc">&nbsp;            return createSetQuery(&quot;tasks.id&quot;, collectIds(taskDTOS), true);</b>
<b class="fc">&nbsp;        } else if (objectType == ObjectType.TASK) {</b>
<b class="fc">&nbsp;            return query;</b>
&nbsp;        }
<b class="nc">&nbsp;        return new BoolQueryBuilder();</b>
&nbsp;    }
&nbsp;
&nbsp;    private QueryBuilder getQueryAccordingToObjectTypeAndSearchInProcess(ObjectType objectType, QueryBuilder query)
&nbsp;            throws DataException {
<b class="fc">&nbsp;        if (objectType == ObjectType.PROCESS) {</b>
<b class="fc">&nbsp;            return query;</b>
<b class="fc">&nbsp;        } else if (objectType == ObjectType.TASK) {</b>
<b class="fc">&nbsp;            List&lt;ProcessDTO&gt; processDTOS = ServiceManager.getProcessService().findByQuery(query, true);</b>
<b class="fc">&nbsp;            return createSetQuery(TaskTypeField.PROCESS_ID.getKey(), collectIds(processDTOS), true);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new BoolQueryBuilder();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This functions extracts the Integer from the parameters passed with the
&nbsp;     * step filter in first position.
&nbsp;     *
&nbsp;     * @param parameter
&nbsp;     *            the string, where the integer should be extracted
&nbsp;     * @return Integer
&nbsp;     */
&nbsp;    private Integer getTaskStart(String parameter) {
<b class="fc">&nbsp;        String[] strArray = parameter.split(&quot;-&quot;);</b>
<b class="fc">&nbsp;        return Integer.parseInt(strArray[0]);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * This functions extracts the Integer from the parameters passed with the
&nbsp;     * step filter in last position.
&nbsp;     *
&nbsp;     * @param parameter
&nbsp;     *            String
&nbsp;     * @return Integer
&nbsp;     */
&nbsp;    private Integer getTaskEnd(String parameter) {
<b class="nc">&nbsp;        String[] strArray = parameter.split(&quot;-&quot;);</b>
<b class="nc">&nbsp;        return Integer.parseInt(strArray[1]);</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Checks the given map for an entry with the key &#39;FILTER_STRING&#39; and parses the corresponding value of the
&nbsp;     * entry as a filter.
&nbsp;     *
&nbsp;     * @param filters
&nbsp;     *      a Map containing a filter String
&nbsp;     * @return
&nbsp;     *      the only Entry&#39;s value as java.lang.String
&nbsp;     */
&nbsp;    String parseFilterString(Map&lt;?, ?&gt; filters) {
<b class="nc">&nbsp;        if (Objects.nonNull(filters) &amp;&amp; filters.containsKey(FILTER_STRING)</b>
<b class="nc">&nbsp;                &amp;&amp; filters.get(FILTER_STRING) instanceof String) {</b>
<b class="nc">&nbsp;            return (String) filters.get(FILTER_STRING);</b>
&nbsp;        }
<b class="nc">&nbsp;        return &quot;&quot;;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Parse Map &#39;filters&#39; and create a map containing filter fields as
&nbsp;     * keys and filter values as values.
&nbsp;     *
&nbsp;     * @param filters Map containing filterString to parse
&nbsp;     * @return HashMap containing filter fields as keys and filter values as values
&nbsp;     */
&nbsp;    public HashMap&lt;String, Object&gt; getSQLFilterMap(Map&lt;?, ?&gt; filters, Class&lt;?&gt; baseClass) throws NoSuchFieldException {
<b class="nc">&nbsp;        HashMap&lt;String, Object&gt; filterMap = new HashMap&lt;&gt;();</b>
<b class="nc">&nbsp;        List&lt;String&gt; declaredFields = Arrays.stream(baseClass.getDeclaredFields()).map(Field::getName)</b>
<b class="nc">&nbsp;                .collect(Collectors.toList());</b>
<b class="nc">&nbsp;        for (String filter : splitFilters(parseFilterString(filters))) {</b>
<b class="nc">&nbsp;            String[] filterComponents = filter.split(&quot;:&quot;);</b>
<b class="nc">&nbsp;            if (filterComponents.length == 2) {</b>
<b class="nc">&nbsp;                String parameterName = filterComponents[0].trim();</b>
<b class="nc">&nbsp;                String parameterValue = filterComponents[1].trim();</b>
<b class="nc">&nbsp;                if (declaredFields.contains(parameterName)) {</b>
&nbsp;                    // class contains parameter as column
<b class="nc">&nbsp;                    if (Objects.equals(baseClass.getDeclaredField(parameterName).getType().getSuperclass(),</b>
&nbsp;                            Number.class)) {
<b class="nc">&nbsp;                        filterMap.put(parameterName, Integer.parseInt(parameterValue));</b>
&nbsp;                    } else {
<b class="nc">&nbsp;                        filterMap.put(parameterName, parameterValue);</b>
&nbsp;                    }
&nbsp;                } else {
&nbsp;                    // otherwise check if parent class contains parameter as column
<b class="nc">&nbsp;                    if (Objects.nonNull(baseClass.getSuperclass())) {</b>
<b class="nc">&nbsp;                        Field field = baseClass.getSuperclass().getDeclaredField(parameterName);</b>
<b class="nc">&nbsp;                        if (Objects.equals(field.getType().getSuperclass(), Number.class)) {</b>
<b class="nc">&nbsp;                            filterMap.put(parameterName, Integer.parseInt(parameterValue));</b>
&nbsp;                        } else {
<b class="nc">&nbsp;                            filterMap.put(parameterName, parameterValue);</b>
&nbsp;                        }
&nbsp;                    }
&nbsp;                }
&nbsp;            }
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return filterMap;</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Create and return an SQL statement to filter users.
&nbsp;     *
&nbsp;     * @param filters
&nbsp;     *          as Set of filter Strings
&nbsp;     * @return SQL statement to filter users
&nbsp;     */
&nbsp;    public String mapToSQLFilterString(Set&lt;String&gt; filters) {
<b class="nc">&nbsp;        StringBuilder sqlUserFilter = new StringBuilder();</b>
<b class="nc">&nbsp;        for (String filter : filters) {</b>
<b class="nc">&nbsp;            sqlUserFilter.append(&quot; AND &quot;).append(filter).append(&quot; = :&quot;).append(filter);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return sqlUserFilter.toString();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Initialise list of process property titles.
&nbsp;     *
&nbsp;     * @return List of String objects containing the process property labels.
&nbsp;     */
&nbsp;    public List&lt;String&gt; initProcessPropertyTitles() {
<b class="nc">&nbsp;        return ServiceManager.getPropertyService().findDistinctTitles();</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Initialise list of projects.
&nbsp;     *
&nbsp;     * @return List of String objects containing the project
&nbsp;     */
&nbsp;    public List&lt;String&gt; initProjects() {
<b class="nc">&nbsp;        List&lt;ProjectDTO&gt; projectsSortedByTitle = Collections.emptyList();</b>
&nbsp;        try {
<b class="nc">&nbsp;            projectsSortedByTitle = ServiceManager.getProjectService().findAllProjectsForCurrentUser();</b>
<b class="nc">&nbsp;        } catch (DataException e) {</b>
<b class="nc">&nbsp;            Helper.setErrorMessage(&quot;errorInitializingProjects&quot;, logger, e);</b>
<b class="nc">&nbsp;        }</b>
&nbsp;
<b class="nc">&nbsp;        return projectsSortedByTitle.stream().map(ProjectDTO::getTitle).sorted().collect(Collectors.toList());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Initialise list of step statuses.
&nbsp;     *
&nbsp;     * @return List of TaskStatus objects
&nbsp;     */
&nbsp;    public List&lt;TaskStatus&gt; initStepStatus() {
<b class="nc">&nbsp;        return List.of(TaskStatus.values());</b>
&nbsp;    }
&nbsp;
&nbsp;    /**
&nbsp;     * Initialise list of task titles.
&nbsp;     *
&nbsp;     * @return List of String objects containing the titles of all workflow steps
&nbsp;     */
&nbsp;    public List&lt;String&gt; initStepTitles() {
<b class="nc">&nbsp;        List&lt;String&gt; taskTitles = new ArrayList&lt;&gt;();</b>
&nbsp;        try {
<b class="nc">&nbsp;            taskTitles = ServiceManager.getTaskService().findTaskTitlesDistinct();</b>
<b class="nc">&nbsp;        } catch (DataException | DAOException e) {</b>
<b class="nc">&nbsp;            Helper.setErrorMessage(e.getLocalizedMessage(), logger, e);</b>
<b class="nc">&nbsp;        }</b>
<b class="nc">&nbsp;        return taskTitles;</b>
&nbsp;    }
&nbsp;
&nbsp;
&nbsp;    /**
&nbsp;     * Initialise list of users.
&nbsp;     *
&nbsp;     * @return List of User objects
&nbsp;     */
&nbsp;    public List&lt;User&gt; initUserList() {
&nbsp;        try {
<b class="nc">&nbsp;            return ServiceManager.getUserService().getAllActiveUsersSortedByNameAndSurname();</b>
<b class="nc">&nbsp;        } catch (RuntimeException e) {</b>
<b class="nc">&nbsp;            logger.warn(&quot;RuntimeException caught. List of users could be empty!&quot;);</b>
<b class="nc">&nbsp;            Helper.setErrorMessage(&quot;errorLoadingMany&quot;, new Object[] {Helper.getTranslation(&quot;activeUsers&quot;) }, logger, e);</b>
&nbsp;        }
<b class="nc">&nbsp;        return new ArrayList&lt;&gt;();</b>
&nbsp;    }
&nbsp;}
</code>
</pre>
</div>

<script type="text/javascript">
(function() {
    var msie = false, msie9 = false;
    /*@cc_on
      msie = true;
      @if (@_jscript_version >= 9)
        msie9 = true;
      @end
    @*/

    if (!msie || msie && msie9) {
      hljs.highlightAll()
      hljs.initLineNumbersOnLoad();
    }
})();
</script>

<div class="footer">
    
    <div style="float:right;">generated on 2023-05-12 13:55</div>
</div>
</body>
</html>
